[["index.html", "Data Analysis for Clinical Researchers Preface", " Data Analysis for Clinical Researchers Albert Cobos Preface This is an introductory book on data analysis for clinical researchers. Data analysis methods are presented through real data examples relevant to clinical research. We focus on concepts, interpretation, and statistical thinking, avoiding or minimizing the mathematical basis of statistical methods, in line with the Guidelines for Assessment and Instruction in Statistics Education (GAISE), and with modern data science. Data analysis requires the use of some software to read and analyze data, and to produce some outputs. There are lots of software tools one may use for this purpose, such as SAS, SPSS, Stata, and many other. This book is based on the R language (R, for short), a programming language for statistical computing and graphics. These are the main reasons to choose R: It is a free and open-source software under the GNU General Public License. May be used with the three major platforms: Windows, Linux and Mac. Has very good graphic capabilities. Is well documented, including an easily accessible help system. It is extensible, and has a growing and very active user community. "],["structure-of-this-book.html", "Structure of this book", " Structure of this book In chapter 1 we present the tools used throughout the book: R and RStudio. Chapter 2 is an introduction to data structures frequently used in R to store data. This is a wearisome subject, but it is important to become familiar with R. The remaining chapters follow the chronological order of tasks to be carried out in any real case of data analysis: acquire the data (chapter 3), prepare the data for analysis (chapter 4), explore the data (chapter 5), conduct inferential analyses (chapters 6-9), and report the results (chapter 10). Throughout the book you will find R tutorials in gray areas containing R code, just like this one: # This will print the date of your system in the console Sys.Date() By hovering the cursor over the top-right corner of gray area, you will be able to copy the whole of its contents, and paste it in the RStudio editor. It is extremely important that you run the R code shown in tutorials (in the first tutorial we provide detailed instructions on how to do this). R programming is a skill, and you won’t develop skills by just reading how to do something. Rather, you need to get your hands dirty by doing. In this case, this means to write R code, or at least copying and running it to see what happens. "],["introduction-to-r-and-rstudio.html", "1 Introduction to R and RStudio 1.1 Installing R and RStudio 1.2 First R session 1.3 R objects 1.4 R functions 1.5 Installing R packages 1.6 Loading packages Resources Exercises", " 1 Introduction to R and RStudio In this chapter we introduce R and RStudio. R is a programming language particularly suited for data analysis and data visualization (via graphics), and its free. Rstudio is an integrated development environment (IDE) that greatly facilitates to work with R, and there is also a free desktop version. 1.1 Installing R and RStudio First of all, you need to have R and RStudio installed in you computer. I you don’t have them, you should proceed as follows: Install the last version of R from the CRAN website; see how in this video. Install the free Desktop version of RStudio from here. Now you have both R and RStudio and, for starters, I recommend you to look at the short video Take a tour of RStudio’s IDE, here. As you have seen in the video, the RStudio screen is divided in different areas or panes, some of which have several tabs. This is a very short description of the main purpose of some of these panes and tabs: The top-left pane is and editor where you can write R code. It is likely that you won’t see this pane when you launch RStudio for the first time after installation. The bottom-left pane is the R Console, and here is where text results will be printed. You can also write R code in the console, after the prompt symbol (&gt;), and submit it by pressing Enter. The top-right pane has several tabs: The Environment tab shows the R objects created in an R session; it will be empty if you have not created any. You will wonder what is an object. Well, the best we can say by now is that anything that exists in an R session is an object. For instance, a collection of data, a graphic, or the results obtained by a statistical analysis procedure, are objects. The History tab shows a log of all the commands you have submitted. The Tutorial tab contains interactive tutorials. The bottom-right pane has several tabs: The Files tab shows the contents of the folder R is pointing to, and is similar to the file explorer in Windows. The Plots tab is where graphics are displayed. The Packages tab is to see and manage R packages. In a fresh installation of R, you will see many packages, but many more can be easily installed from this tab. The Help tab is where you can look for information of specific R commands or functions, and contains several resources to learn R and RStudio, R manuals, and more. The Viewer tab is used to show results that are formatted in specific ways, such as html. This is a lot of information, and is presented just for reference. But don’t worry, you will get familiar with all these as you use RStudio. 1.2 First R session It’s time to open RStudio and have your first R session, proceeding as follows: Open RStudio. Open a new scripting tab using the menu option File &gt; New file &gt; R script: a new tab will appear in the top-left pane, with name Untitled1. Copy the R script in the gray area below and paste it in this new tab (you can easily copy the script using the Copy to clipboard icon that will appear on hovering the cursor over the top-right corner of the gray area). Place the cursor in the very first line you pasted, and press Ctrl+Enter (or click the Run icon in the top-right corner of the Untitled1 tab). The code will be submitted to the console and the result will be printed below. In addition, the cursor will move to the next line, so that you can directly press Ctrl+Enter again to run the line. Note that texts preceded by a hash (#) are comments, and are ignored by the R interpreter. In this first tutorial we show how to use R as a calculator, and we introduce some common mathematical functions, such as sqrt(), exp(), log(), and round(). # Arithmetic operators 10 + 2 # addition 10 - 2 # subtraction 10 * 2 # multiplication 10 / 2 # division 10 ^ 2 # power # Combine them, using brackets for precedence as in standard maths notation 2 * 10 -1 # usual precedence rules 2 * (10 -1) # use brackets for precedence # Mathematical functions sqrt(25) # square root exp(1) # exponential log10(100) # decimal log log(10) # natural log # Combine functions with arithmetic operators or with other functions sqrt(25) * log10(100) / 10^2 # Nested functions: use functions within functions sqrt(exp(2)) # square root of the exponential of 2 exp(sqrt(2)) # exponential of the square root of 2 # Round to the desired number of decimals round(3.141593, 2) round(3.141593, 0) round(3.141593) Once you have finished the tutorial, you can save the script in the Untitled1 pane to a file, using the save button, or the File &gt; Save menu option. This will open a dialog from which you can navigate to a desired folder, provide a file name (e.g. my_first_R_session) and click the Save button. A new file will appear in the folder you chose, named my_first_R_session.R. The .R extension means that this is an R script file. If you save an R script to file, you will be able to reopen it in RStudio using the menu option File &gt; Open file.... We recommend you save the scripts of all the tutorials in this book, so that by the end of it you will have a nice collection of examples to refer to in the future. 1.3 R objects In the previous tutorial we produced some results that were printed in the console, but we did not save any. In this tutorial you will learn how to store your results in objects. In particular, you will learn: how to create an object by assigning some result to an object name with the assignment operator &lt;- (a handy way to compose this operator in RStudio is by pressing Alt+-). that R is case-sensitive: lowercase and uppercase letters are not the same, e.g., \\(A \\ne a\\). how to remove objects from the workspace (Environment tab), with function rm(). how to save the objects in the workspace to a file, with function save.image(), and how to load these file at a later time, with function load(). how to know what is the current working directory in an R session (the folder of your computer R is pointing to), with function getwd(). Before you start, ensure that the workspace (Environment tab of the top-right pane of RStudio) is empty. If it’s not, you can delete all objects listed by using the brush icon. # Create object by assigning a name to a value or expression, # using the assignment operator: &lt;- weight &lt;- 90 height &lt;- 1.80 BMI &lt;- weight / height^2 # These objects now appear in the Environment tab # When you create an object, its contents is NOT printed in the console # to print (the contents of) an existing object, just run its name weight BMI # Object names cannot include blank spaces body weight &lt;- 90 # this is wrong (and gives an error) body_weight &lt;- 90 # this is ok # The assignment operator is an arrow composed with a left angle bracket (&lt;) and # a hyphen or dash (-), WITHOUT blank spaces between them weight &lt; - 50 # this is wrong... but does not give error: why? # Case sensitivity bmi # gets an error: there is no object with this name BMI # ok Round(BMI, 1) # gets an error: there is no function with this name round(BMI, 1) # ok # Care when using both upper and lowercase names a &lt;- 1 A &lt;- 2 A == a # is A equal to a ? a A # Remove objects with function rm() rm(body_weight, a, A) # Now the environment has only three objects: BMI, height and weight # Save your workspace (i.e., all objects in there) to a file save.image(&quot;my_objects.RData&quot;) # A file of name &quot;my_objects.RData&quot; was saved to your working directory # The working directory is the folder R is pointing to. # But what is this folder? getwd() # Now, close RStudio and reopen it for a fresh new session, or # simulate a new session by just removing all objects in the workspace. # This will load the file you saved load(&quot;my_objects.RData&quot;) # Now you should see the objects back in the Environment tab Note that, with RStudio, you can change the working directory using the menu option Session &gt; Set working directory. Alternatively, you can use function setwd() to specify the folder in your computer you want to become the working directory, as in this example: setwd(&quot;C:/Users/acobo/Documents&quot;) A warning for Windows users: note the route of a folder shoud be specified using forward slashes (/). 1.4 R functions An R function is what we use to make something happen. Functions perform a specialized task and provide a result. In previous sections we used some functions, like log(), round(), and Sys.Date(), but there are many other built-in functions in R. In the following tutorial we discuss some general ideas about R functions, how to use them and how to get help on them. To use a function we write its name followed by brackets. Often (but not always), we write some things within the brackets which are called function arguments. A function may take one or more arguments, or no arguments at all. When a function takes more than one argument, we separate them with commas. # a function with no arguments Sys.Date() # a function call with one argument round(10/3) # a function call with two arguments (comma separated) round(10/3, 2) # a function call with three arguments (comma separated) hist(rnorm(100), main = &quot;Histogram (n = 100)&quot;, xlab = &quot;Z score&quot;) The arguments a function can take do have names. When calling a function, arguments can be identified either by name (if explicit), or by position (otherwise). For instance, the round function can take two arguments: x: the number we want to round. digits: the number of decimals we want to round x to. # arguments identified by name: order is irrelevant round(digits = 2, x = 10/3) # arguments identified by position: order is relevant! round(10/3, 2) # a mixture of both; order is relevant for arguments not explicitly named! round(10/3, digits = 2) # how to know the arguments a function can take, and their names? # looking at the function help with ?function_name, e.g.: ?round The help of a function is always structured in several sections, like Description, Usage, Arguments, Details, and Examples. In the Arguments section you can see what are the argument names, an explanation of what they are, and their order. You can access the help of a function by running its name (without the brackets!) after a question mark (e.g., ?round), or writing the function name in the search box of the RStudio Help tab of the bottom-right pane. 1.5 Installing R packages R is a software structured in packages. A package is a bunch of functions packed together. When you install R, a collection of packages is downloaded to your computer. If you look at the Packages tab of RStudio (bottom-right pane) you will see the packages that are already installed. For instance, you will see packages base and stats, since they come with the basic installation of R. However, there are many other packages available in the CRAN repository, and you need to know how to install them. For instance, there is a package called mosaic you will probably not find among your installed packages. Since we will use this package in future chapters, it’s a good idea to install it. To install a package, click the Install button in the Packages tab of RStudio and you will be presented the dialog shown in figure 1.1. Figure 1.1: Dialog to install a package You only need to write the name mosaic in the Packages box (or pick it from the list that will appear as you start writing) and click on the Install button. Be sure the Install dependencies box is checked (dependencies are other packages needed by the one you are installing). You will notice that, when you click the Install button, the following is written in the R console: install.packages(&quot;mosaic&quot;) This means that the install.packages() function is what is actually used to install packages, and the Install button in RStudio only sends this to the console. After running this function, you will see a confirmation message in the console (package ‘mosaic’ successfully unpacked and MD5 sums checked). Installing a package means downloading it to your computer, and therefore is a one time operation: you need to do it just once per R installation. 1.6 Loading packages In previous sections we have used functions from packages in the base R installation such as round(), log() and others. These functions are readily available in any R session, but this is not the case of functions contained in packages you install. For instance, the following script calls favstats(), a function from the mocaisc package, but when we run it we get an error message stating that function favstats() was not found: favstats(age ~ sex , data = HELPrct) Error in favstats(age ~ sex, data = HELPrct): could not find function &quot;favstats&quot; To use a function from packages you have installed, you need to do something special, and there are two options: prefix the function with the package name plus ::, as in mosaic::favstats(), or load the package first using function library(). # Option 1 mosaic::favstats(age ~ sex , data = HELPrct) sex min Q1 median Q3 max mean sd n missing 1 female 21 31 35 40.5 58 36.25234 7.584858 107 0 2 male 19 30 35 40.0 60 35.46821 7.750110 346 0 # Option 2 library(mosaic) favstats(age ~ sex , data = HELPrct) sex min Q1 median Q3 max mean sd n missing 1 female 21 31 35 40.5 58 36.25234 7.584858 107 0 2 male 19 30 35 40.0 60 35.46821 7.750110 346 0 As you see in the previous scripts, both options work, but while library(mosaic) in option 2 loads the entire package into memory, prefixing the function with the package name (option 1) does not. Another important difference is that prefixing the function with the package name makes explicit the function you are using, and this may be important because some packages have functions sharing their name with some base R functions. For instance: The base package has a function mean() (see ?base::mean). The mosaic package has a function mean() (see ?mosaic::mean). Then, which one is going to be used when we call mean()? Well, if you load the mosaic package with library(mosaic), the following warning is printed in the console: The following objects are masked from ‘package:base’: max, mean, min, prod, range, sample, sum) This means that, from now on in your session, every time you call one of the functions mentioned in the above message (such as mean()), the one from mosaic will be used. However, when you look at a long script and see a call to mean(), it may be hard to know if this refers to mean() from the base package, or to mean() from the mosaic package. Prefixing a function with the package name (e.g., mosaic::mean()) removes any possible ambiguity, and for this reason, is considered a good programming practice. Last, in case you prefer to avoid prefixing functions with the package name, remember to load the package first with library(), and to do it in every new R session. While installing a package is a one time operation, loading an installed package is an operation you need to do in every R session (every time you open RStudio). Resources CRAN is the official website of R. Here you can not only download R, but also find useful information, such as the CRAN task views providing guidance on which packages are relevant for tasks related to a certain topic. The RStudio website has a Resources section where you can find webinars and videos, cheatsheets and books, among other things. A two-pages RStudio IDE Cheat Sheet. R-bloggers is a blog on R publishing lots of articles on the use of R, including tutorials for learning R. A post is R-bloggers on how to use the help page for a function in R Another post is R-bloggers with a complete guide to installing R packages form CRAN and other R package repositories. Quick-R is an extremely well organized website on R, particularly useful for beginners. There are sections on data management, statistics, graphics and more. Exercises Look at the help of round() and read sections Description and Usage. What do you get when using floor(10/3) and ceiling(10/3)? In the Usage section you will see round(x, digits = 0). What do you think digits = 0 means? (hint: read the explanation of round in the Description section). Start at fresh RStudio session (or empty the workspace) and write a script in a new editor tab (File &gt; New File &gt; R script) to: Create an object with name my_weight taking the value of your body weight, in kilograms. Create an object with name my_height taking the value of your body height, in meters (remember to use the dot as decimal separator, e.g. 1.78) Compute the body mass index (by dividing the weight over the square of the height) and assign it to an object with name BMI. Round the value of BMI to the first decimal. Look for a package called dplyr in the Packages tab of RStudio. If you are working with a new installation of R, you will not find it. Then, install this package using the Install button in this tab. When the installation finishes, verify that this package now appears in the Packages tab. Open RStudio and investigate what is your working directory with function getwd(). Then change it to another folder of your preference with the menu option Session &gt; Set working directory &gt; Choose Directory.... When done, use again getwd() to see what is now the working directory. "],["r-data-structures.html", "2 R data structures 2.1 Vectors 2.2 Lists 2.3 Dataframes 2.4 Factors 2.5 Dates 2.6 Other data structures Resources Exercises", " 2 R data structures The term data structures refers to objects devoted to store data. There are many different data structures in R. In this chapter we introduce the most basic, and commonly used ones. 2.1 Vectors Vectors are the simplest possible objects in R (sometimes called atomic objects). They are ordered collections of elements. There are six types of vectors in R, but here we will be concerned with the three types listed in table 2.1. Table 2.1: Vector types Type Elements are: Example numeric (real) numbers 1, 0, 3.14, 1984 character (quoted) character strings “Yes”, “No”, “Maybe” logical (unquoted) logical values TRUE, TRUE, FALSE, TRUE A vector can contain any number of elements, but all of them have to be of the same type: we cannot mix different data types in a single vector (e.g., character and numeric elements). In the following tutorial you will learn how to create vectors with function c(), verify what is the type of a vector with function class(), and what is the number of its elements with function length(). A vector can have missing elements, and these are represented with the symbol NA. Last, you will see how to get particular elements in a vector with the subsetting operator [], and how to set them using the assignment operator &lt;-. # Creating vectors with function c() ages &lt;- c(51, 65, 90, 93, 72) # a numeric vector ages antec &lt;- c(&quot;stroke&quot;,&quot;AMI&quot;,&quot;Breast ca.&quot;) # a character vector antec current_smoker &lt;- c(FALSE, FALSE, TRUE) # a logical vector current_smoker mixed &lt;- c(67, &quot;stroke&quot;, FALSE) # try to mix types: no error issued ? mixed # but coerced to character (note the quotes) # Getting the type of a vector class(ages) class(antec) class(current_smoker) class(mixed) # Getting the number of elements in a vector length(ages) length(antec) length(current_smoker) # Use the symbol NA for missing elements more_ages &lt;- c(69, NA, 37) more_ages all_ages &lt;- c(ages, more_ages) # can concatenate vectors with c() all_ages # Getting/setting vector elements # Refer to an element by position using square brackets: all_ages all_ages[7] # gets the 7th element all_ages[7] &lt;- 65 # sets the 7th element to 65 all_ages # verify all_ages[3:6] # gets elements from positions 3 to 6 Very often we need of perform arithmetic operations with numeric vectors. For instance, we may want to compute the body mass index (BMI) from a vector of body weights and a vector of body heights. Then, we may want to compute summary statistics of the BMI values, like the mean and standard deviation. weight &lt;- c(51, 65, 90, 93, 85) # weights of five patients height &lt;- c(1.65, NA, 1.85, 1.80, 1.60) # heights of the same five patients # Arithmetic operations bmi &lt;- round(weight / height^2, 1) # compute BMI bmi # result is NA if height or weight is NA # Statistical functions mean(weight) # the mean of weights median(weight) # the median sd(weight) # the standard deviation summary(weight) # some of the previous at once # Care with missings! If a vector contains missing data (NA), # you need to set argument na.rm = TRUE in most statistical functions: mean(bmi) # since some values are NA, result is NA mean(bmi, na.rm=TRUE) # removes NA for calculation sd(bmi) # same for sd() sd(bmi, na.rm=TRUE) summary(bmi) # but not needed for summary() Also, a very common task is to compare the elements of a numeric vector to some threshold value using relational operators such as ==, !=, &gt;, or &gt;=. We can also compare two vectors x and y element-wise, provided they have the same length (e.g., x == y). In any case, the result of a comparison is always a logical vector. Note that the equality operator is not a single (=) but a double equal sign (==): try to remember this, it’s a very common mistake! Another very common mistake is to compare something to NA using the equality operator (==): this does not work, and function is.na() should be used for this purpose. Comparisons are illustrated in the following tutorial, which is a continuation of the previous one (do not empty the workspace!). # Relational operators for comparisons bmi == 18.7 # is bmi equal to 18.7? note the DOUBLE equal sign! bmi != 18.7 # is x different from 18.7? bmi &lt; 25 # is bmi less than 25? bmi &lt;= 25 # is bmi less than, or equal to 25? bmi &gt; 30 # is bmi greater than 30? bmi &gt;= 30 # is v greater than, or equal to 30? # Can also compare two vectors having the same number of elements x &lt;- c(1, 0, 0, 0, 1, 0, 0, 0, 1) y &lt;- c(0, 0, 1, 1, 1, 1, 1, 0, 0) x == y x != y x &gt; y x &lt;= y # Very important! bmi == NA # this does not work with NA is.na(bmi) # use this instead Character vectors are useful to store textual information like diseases, symptoms or drugs. However, working with character data (sometimes called strings) is often a challenge for several reasons. First, a word may be written in lowercase, uppercase, or a mixture of both. Because R is case sensitive, “stroke” is not the same as “STROKE”. Second, white spaces are also characters (though they do not catch the eye!) and therefore “stroke” and “stroke \\(\\;\\)” are also different. For these reasons, it is sometimes useful to convert character vectors to uppercase (or lowercase), and to know how to remove leading or trailing blanks. Here is a demo: # Working with character vectors antec &lt;- c(&quot;stroke&quot;, &quot; stroke &quot;, &quot;Breast cancer&quot;, &quot;STROKE&quot;, &quot; Stroke &quot;) # Remember case sensitivity: # &quot;stroke&quot;, &quot; stroke &quot;, &quot;STROKE&quot;, and &quot; Stroke &quot; are different things! antec == &quot;stroke&quot; toupper(antec) # convert to uppercase tolower(antec) # convert to lowercase trimws(antec) # remove leading and trailing blanks tolower(antec) == &quot;stroke&quot; # useful for comparisons trimws(tolower(antec)) == &quot;stroke&quot; # better A very useful function to combine strings is the paste() function. In fact, you can combine not only strings, but also numeric values (that will be coerced to character). Sometimes we need to know what is the number of characters of the elements of a character vector, and this can be done with function nchar(). patient_no &lt;- 1:5 age &lt;- c(62, 88, 35, 75, 81) sex &lt;- c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;) paste(patient_no, sex) # paste corresponding elements paste(patient_no, sex, sep = &quot;: &quot;) # can define a separator (default is a blank space) # Can paste more than two vectors, and mix with constants strings (&quot;Patient&quot;, &quot;is a&quot;) # note that constants are recycled (i.e., reused for all elements) narrative &lt;- paste(&quot;Patient&quot;, patient_no, &quot;is a&quot;, age, &quot;years old&quot;, sex, &quot;with antecedent of&quot;, trimws(tolower(antec))) narrative # Number of elements and number of characters length(narrative) # the number of elements in vector nchar(narrative) # the number of characters of each element Other common tasks with the strings are to extract just a part of them, or to substitute a part of them. These can be done with functions substr() (for substring) and sub() (for substitute), respectively. In both functions we indicate the character vector from which to extract or substitute a part in the first argument (named x). In substr() we need to specify the part we want to extract from x by indicating the first and last positions in arguments start and stop, respectively. In sub() we need to specify the pattern to be replaced, the replacement string, and the addition argument fixed = YES to avoid alternative interpretations of the pattern argument 1. # Extract a part of the string substr(narrative, start = 16, stop = 23) # characters 16 to 23 substr(narrative, 16, 17) # characters 16 to 17 substr(narrative, 16, nchar(narrative)) # characters 16 to last # Replace a part of the string sub(pattern = &quot;is&quot;, replacement = &quot;was&quot;, x =narrative, fixed = TRUE) Whatever the type of a vector, its elements can be named. We can provide names for the elements of a vector when creating it with function c(), or later with names() &lt;- . x &lt;- c(Peter = 31, Paul = 28, Mary = 25) x names(x) # gives the names as a character vector names(x)[3] # therefore, you can refer to any element names(x)[3] &lt;- &quot;Adeline&quot; # or set any element x y &lt;- 1:3 # a numeric vector names(y) # whose elements have no names names(y) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # but we can set them later y Last, it is possible to make type conversions. For instance, you may need to convert a numeric vector containing zeros and ones to a logical vector, or viceversa. Sometimes, you want to extract part of a string containing digits with substr(). However, because a part of a string is by definition a string as well (even if it contains only digits!), we need to convert these to numeric. Other conversions are less common but possible, using a family of functions, the as. family. In some instances, type conversions are done automatically. For example if we try to sum the elements of a logical vector: because addition is an operation defined on numbers, logical values will be coerced to numeric behind the scene, as shown at the end of the following tutorial on type conversions. number_of_seizures &lt;- 0:4 number_of_seizures # numeric to logical (rule: 0 -&gt; FALSE, anything else -&gt; TRUE) seizures &lt;- as.logical(number_of_seizures) seizures # character to numeric x &lt;- substr(narrative, 16, 17) # extracts the age x class(x) # but the result is a character vector age &lt;- as.numeric(x) # now it&#39;s a numeric vector age class(age) # logical to numeric (rule: FALSE -&gt; 0, TRUE -&gt; 1) diabetes &lt;- c(TRUE, TRUE, FALSE, FALSE) as.numeric(diabetes) # character to numeric or logical (less common) z &lt;- c(&quot;0&quot;, &quot;One&quot;,&quot;2&quot;,&quot;120&quot;, &quot;TRUE&quot;, &quot;FALSE&quot;, &quot;Are you tired?&quot;) z as.numeric(z) # only digits converted to numbers as.logical(z) # only words &quot;TRUE&quot; and &quot;FALSE&quot; converted to logical # Automatic conversion from logical to numeric (rule: FALSE -&gt; 0, TRUE -&gt; 1) sum(diabetes) Ops! just one more thing. In R, scalars (single numbers) are considered vectors of length one. Same for a single character string, or a single logical value. So, nothing exists in R simpler than a vector! x &lt;- 3.14 class(x) is.vector(x) length(x) x &lt;- &quot;A&quot; class(x) is.vector(x) length(x) x &lt;- FALSE class(x) is.vector(x) length(x) 2.2 Lists In the previous section we have seen that vectors cannot mix data types, but lists can. In fact, lists can mix not only data types, but object types. Lists are arbitrary collections of objects (including other lists!), and therefore provide a highly flexible structure to store data of any kind. Lists can be created with function list(), by enumerating its elements separated by commas. The length of a list is the number of elements it contains, and can be obtained with length(). # Creating a list x &lt;- list(&quot;male&quot;, # 1st element 79, # 2nd element c(&quot;arterial hypertension&quot;, &quot;diabetes&quot;, &quot;stroke&quot;), # 3rd element matrix(c(260,110, 190, 100, 185, 100, 160, 95), nrow=2, # 4th element dimnames = list(BP = c(&quot;SBP&quot;, &quot;DBP&quot;), day = 1:4))) x class(x) # object type? length(x) # number of elements it contains When working with lists, two common operations are subsetting and extraction: Subsetting a list means taking a part or subset of the list elements, and the result is always a list (even when we subset just one of its elements!); this is done with the subsetting operator: []. Extracting from a list, means getting an element of the list, and the result will not be a list, but an object of the class this element belongs to; this is done with the extraction operator: [[]]. When applied to vectors, these two operators produce the same result (x[3] == x[[3]]), but this is not the case with lists. For instance, in the example above, we created a list with data from a patient, the second of which elements is the age, a numeric vector of length one. Suppose we want to get this value and plug it in some mathematical formula. In this case we need to extract this element (x[[2]]), the result being a numeric vector we can use in arithmetic expressions. However, if we subset the second element of the list (x[2]), the result will be a list of length one (but still a list!), and we cannot plug a list in a mathematical expression. The following tutorial demonstrates this important difference. # Subset a list with the SUBSETTING operator: [] x[1:2] class(x[1:2]) # the result will be ALWAYS another list x[2] # even when subsetting just one element! class(x[2]) # see? # Extract an element from a list with the EXTRACTION operator: [[]] x[[2]] class(x[[2]]) # the result is the element class (numeric vector in this case) # We can use numeric vectors in mathematical expressions, but NOT lists! x[[2]] + 10 # is OK x[2] + 10 # is WRONG People is often confused about the difference between x[2] and x[[2]]. If this is your case, think of a list as a set of numbered boxes, each one containing something. Suppose that box number 2 contains a sandwich. Subsetting the list means taking some of the boxes, maybe just one, maybe just box number 2, but you still have a box in your hands and you can`t eat a box! If you want to eat your sandwich, you open the box to extract your sandwich, and then you eat it. If you are hungry, you better understand the difference between subsetting a list and extracting from a list. Just like vectors, lists can be named, and the names of elements can be provided when creating the list, or later with names(). In the previous tutorial we saw how to extract a single element from a list indicating its position with the extraction operator [[]]. When a list has names, we can extract elements by position, but also by name, using either the extraction operator or the construct listname$elementname. The last is very practical, and is shown below: # Provide names when creating the list x &lt;- list(sex = &quot;male&quot;, age = 79, antecedents = c(&quot;arterial hypertension&quot;, &quot;diabetes&quot;, &quot;stroke&quot;), matrix(c(260,110, 190, 100, 185, 100, 160, 95), nrow=2, dimnames = list(BP = c(&quot;SBP&quot;, &quot;DBP&quot;), day = 1:4))) x names(x) # get the names names(x)[4] # 4th element has no name names(x)[4] &lt;- &quot;BP&quot; # let`s set it names(x) # all named now # Extract an element x[[1]] # by position x[[&quot;BP&quot;]] # by name x$age # by name, using $ x$sex x$antecedents x$BP Lists are very important data structures for several reasons, but one of them is because the results produced by many functions in R, including functions for statistical analysis, are stored in a list. For instance, in the following tutorial we use a binomial test2 to evaluate if fathering a boy or a girl are equal likely, from a series of 100 deliveries. Then, we inspect the result to realize it is a list, we investigate the name of its elements, and we extract some of them. # A binomial test for the probability of boy being 0.5 # suppose we observe n = 100 births, among which x = 45 are boys res &lt;- binom.test(x = 45, n = 100) res class(res) # class &quot;htest&quot; is a specialized type of list, but still a list is.list(res) # see? names(res) # get the names of its elements res$p.value # get the p.value res$estimate # get the proportion of boys res$conf.int # get the confidence interval for this proportion 2.3 Dataframes Dataframes are named lists of vectors, all having the same length. Because they are lists, they can mix vectors of different types, making dataframes ideal to store tabular data (arranged in rows and columns). Dataframe vectors are the columns of a data frame, and are usually called variables. Dataframes can be created with data.frame(), by enumerating its vectors separated by commas. These can be already existing vectors, or vectors we create on the fly. The length()of a dataframe is the number of variables it contains. Because dataframes are named lists of vectors, we can refer to these vectors using the construct dataframename$variablename. This can be used in conjunction with the assignment operator to add a new variable to a dataframe, or to remove an existing variable from a dataframe (by passing it NULL), as shown in below. sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) w &lt;- c(60, 69.5, 83.9, 76.3, 77.3, 88.8) # Creating a dataframe from vectors of the same length) d &lt;- data.frame(case = 1:6, # vector created on the fly age = c(25, 32, 19, 41, NA, 56), # same sex, # already existing vector weight = w) # same, but give it a name d class(d) length(d) # number of variables (columns) ncol(d) # same nrow(d) # the number of rows names(d) # get variable names as a character vector # Get dataframe variables d[[2]] # by position d$age # by name class(d$age) # class of this object? class(d$sex) # Note that sex and d$sex are two different objects sex == d$sex # equal by now sex[3] &lt;- NA # change sex sex # verify change d$sex # d$sex remains unaltered # Add variable to a dataframe d$height &lt;- c(165, 175, 158, 180, 175, 160) length(d) d # Remove variable from a dataframe d$case &lt;- NULL length(d) d The data.frame() function is not the only way to create a dataframe. In the next chapter you will learn how to read data stored in an external file (e.g., an Excel file), resulting in a dataframe. This is in fact a very common way to create a dataframe. 2.4 Factors A factor is the data structure used in R to represent categorical variables. Categorical variables are classifications having a number of classes, categories or levels. Examples of categorical variables are sex (male or female), smoker (never smoked, ex-smoker or current smoker) or previous surgery (yes or no). Data on a categorical variable is usually stored as either a character vector of level descriptors (e.g., “male”, “male”, “female”, …), or as a numeric vector using numeric codes (e.g., 1 for males, 2 for females). Factors are created with function factor(). The first argument to this function is the (numeric or character) vector containing the data. If numeric, we need to clarify the meaning of numeric codes, with two additional arguments: levels: to specify the numeric codes (as a numeric vector) labels: to specify the corresponding texts (as a character vector) The following script shows how to create a factor from a numeric vector. We first create a numeric vector x using the rep() function (to repeat values 1 and 2, five times), and then define a factor from it. x &lt;- rep(1:2, 5) # numeric vector using rep() x # Creating a factor from a numeric vector sex &lt;- factor(x, levels = c(1,2), labels = c(&quot;male&quot;, &quot;female&quot;)) sex class(sex) A couple of things are worth noting in the previous example. First, both levels and labels have to be passed as vectors. Second, it is the order of levels and labels what establishes their correspondence: first level with first label, second level with second label, and so on. Last, when a factor (like sex) is printed to the console, its values are not surrounded by quotes (as is the case with character vectors), and the levels of the factor are stated after printing the values. Let’s now see how to define a factor from a character vector. In this case, if the strings of this vector are self-explanatory (e.g., “male”, o “female”), we only need to specify the character vector from which the factor is to be created. However, the levels will be defined in alphabetical order, and this is not always what we want. If we want a specific ordering of the levels, we can just define them in the levels argument. Last, if the strings are not self-explanatory, or we want to change them, we can also use the labels argument. The following script illustrates these three options. x &lt;- rep(c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;), 2) x # option 1: levels and labels not explicitly defined hb &lt;- factor(x) hb class(hb) levels(hb) # option 2: define levels to force desired ordering hb &lt;- factor(x, levels = c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;)) hb class(hb) levels(hb) # option 3: define levels and labels x &lt;- rep (c(&quot;l&quot;, &quot;n&quot;, &quot;h&quot;), 2) hb &lt;- factor(x, levels = c(&quot;l&quot;, &quot;n&quot;, &quot;h&quot;), labels = c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;)) hb class(hb) levels(hb) You may be wondering why we should care about the ordering of the levels of a factor. The reason is this ordering has implications for graphics, tables and statistical analyses. For instance, when we tabulate results of a factor, its levels appear in the order they are defined. Also, the first level of a factor, which is sometimes called the reference level, is the one other levels will be compared to in some analyses such as ANOVA or regression models. For this reasons, it is convenient to ensure a reasonable ordering of factor levels. 2.5 Dates Date is a class of objects used to represent dates in R. There are two related object classes that are used to represent date-time values (values that combine date and time, such as “21/03/2020 07:45:28”): POSIXct, and POSIXlt. When we have just date values (e.g., “21/03/2020), the appropriate class to use is Date. Dates can be created from a character vector with as.Date(). The format argument is used to specify the formatting of the character strings. If these are formatted as yyyy-mm-dd, we don’t need to specify the format value, but otherwise we need to specify it. Dates can be created from POSIXct and POSIXlt objects as well. # From a character vector of yyyy-mm-dd values x &lt;- c(&quot;1958-03-05&quot;, &quot;1991-10-28&quot;) x class(x) dob &lt;- as.Date(x) dob class(dob) # From a character vector of dd/mm/yyyy values x &lt;- c(&quot;05/03/1958&quot;, &quot;28/10/1991&quot;) x class(x) dob &lt;- as.Date(x, format = &quot;%d/%m/%Y&quot;) dob class(dob) # see help on format symbols (Details section) ?strptime # From POSIXct or POSIXt values x &lt;- as.POSIXct(c(&quot;1958-03-05 07:30:04&quot;, &quot;1991-10-28 10:05:39&quot;)) x class(x) dob &lt;- as.Date(x) dob class(dob) The reason why we should store dates in a Date object is to allow computations. For instance, we can compute the current age from birth dates. Or, we can determine the date in ninety days from today. When we operate on dates, the result is not a standard numeric value, but a difftime object. However, we can convert it to numeric with as.numeric(). This is recommended before further operations with time intervals. dob &lt;- as.Date(c(&quot;1958-03-05&quot;, &quot;1991-10-28&quot;)) # birth dates dob class(dob) today &lt;- Sys.Date() # current date today class(today) today + 90 # 90 days from today # Current age age &lt;- today - dob1 # difference as number of days age class(age) # a difftime object # Use as.numeric to get standard numeric vector age &lt;- as.numeric(today - dob1) age class(age) # To compute age in years we divide the NUMERIC version by 365.25 age_in_years &lt;- as.numeric(today - dob1) / 365.25 age_in_years # Use floor() to get whole years age_in_years &lt;- floor(as.numeric(today - dob1) / 365.25) age_in_years 2.6 Other data structures The data structures presented in previous sections are those you will be using again and again, so it’s really important you get familiar with them. In this section we briefly introduce a couple of additional data structures, because you may find them when looking at the help of some functions. These are matrices and arrays. A matrix is just a vector with a dim attribute defining the dimensions of the matrix, that is, the number of rows and columns. A matrix can be created with function matrix(), or by defining the dim attribute of a vector with dim(). Like vectors, matrices cannot mix data types (e.g., character and numeric). x &lt;- 1:10 # a vector x class(x) # Create a matrix of 2 rows and 5 cols m &lt;- matrix(x, nrow = 2) m dim(m) class(m) dim(x) # vectors do not have a dim attribute dim(x) &lt;- c(2, 5) # but we can define it x # and now its a matrix class(x) dim(x) Matrices are a special case of a more general data structure called array. In fact, a matrix is an array with two dimensions (rows and columns) but, in general, arrays can have multiple dimensions. Arrays are created with function array(), or by defining the dim attribute of a vector. x &lt;- 1:30 # Creating an three-dimensional array a &lt;- array(x, dim = c(3, 5, 2)) a class(a) dim(a) dim(x) # vectors do not have a dim attribute dim(x) &lt;- c(3, 5, 2) # but we can define it x # and now its an array class(x) dim(x) For more information on matrices and arrays see this section of the first edition of the book Advanced R by Hadley Wickham. Resources A very useful base R cheat sheet: a pdf with only two pages! Objects types and some useful R functions for beginners is a post in R-bloggers where you can find many of the concepts we covered in this chapter, and more. Fore a more thorough discussion of what we covered in this chapter, look at Data structures in the first edition of the book Advanced r by Hadley Wickham. Exercises Before undertaking each exercise, ensure your workspace is clean (i.e., there are no objects in the Environment pane). Create a vector w of body weights in kilograms, and a vector h of body heights in centimeters, with the following values corresponding to 10 patients: w: 47.3, 87.0, 80.9, 85.1, 95.4, 90.0, 70.3, 46.9, 86.7, 74.0 h: 160, 165, 180, 170, 190, 180, 172, 156, 170, 169 Then compute the body mass index (kg/m^2), store it as bmi, and write appropriate expressions to: Verify that bmi is a numeric vector. Get the number individuals with low weight (BMI below 18.5). Get the number individuals with overweight (BMI of 25 or more). Get the number individuals with obesity (BMI of 30 or more). Get the mean and standard deviation of bmi values. Hint: remember that the result of a comparison is a logical vector, and that the sum of a logical vector is the number of TRUEs it contains. LETTERS and lettersare built-in vectors containing all the letters in the alphabet (print them in the console to see them). What is length(letters)? Using these vectors, get the following: The letter in position 20. A character vector with the first five LETTERS only. A character vector whose first element is “A is an uppercase LETTER, and a is a lowercase letter” (and similar statements for the remaining letters). Hint: use the paste() function. A character vector whose first element is “A is in position 1 of the alphabet” (and similar statements for the remaining letters). Hint: use 1:length(LETTERS) in the paste() function. What is the result of 1:length(LETTERS)? The following are five CIP codes, whose structure is as follows: the first four characters are initials of surname and first name, the first digit is a code for sex (0 for male, 1 for female), followed by birth date in format yyddmm, and three trailing zeros: YAGU0741511000, DEFO0702702000, GITI1642102000, AOPU1620401000, BABE0740206000 Define vector cip containing these CIP codes and then: Get a vector containing the two digits corresponding to the year of birth. Is it a numeric vector? Get a vector of four-digit years of birth by adding 1900. Using only the year of birth (ignore month and day of birth), get an estimate of their ages by 2050. Get a vector with first element “YAGU was born in 1974” (and analogous for the remaining persons). See the help of the rep() function by running ?rep, and look at the first two examples. Use this function to create three vectors containing the following elements: 0, 1, 0, 1, 0, 1 0, 0, 0, 1, 1, 1 “male”, “female”, “male”, “female”, “male”, “female” rep(0:1, 3) rep(0:1, each = 3) rep(c(&quot;male&quot;, &quot;female&quot;), 3) See the help of the seq() function by running ?seq, and look at the examples. Use this function to create vectors containing: All multiples of five up to 100. All odd numbers between zero and ten. The following four probabilities: 0.2, 0.4, 0.6, 0.8. Run the following code to conduct a t-test on the lwb data in package COUNT (you need to install this package if you do not have it!): library(COUNT) data(lbw) res &lt;- t.test(bwt ~ smoke, data = lbw) res What is the class of object res? Is it a list? What are the names of the elements in res? Get the p-value of the test, with 3 decimals. Get the means of bwt for smokers and non-smokers, rounded to one decimal. Get their difference with function diff(), and round to one decimal. Get the confidence interval for this difference, rounded to one decimal. In one step, create a dataframe with these data: first_name age sex Peter 33 male Paul 29 male Mary 25 female Then extend this dataframe with the following additional variables: case_id containing numbers 1 to 3. age_in_10y reflecting the age they will have in 10 years from now. older_than_30 as TRUE or FALSE. is_male as TRUE of FALSE. Remove variable is_male from the dataframe What is now the length of the dataframe? and what is the number of rows? Using the rep() function, create numeric vector x with the sequence 1,2,3 repeated 3 times (so 9 values), an then define a factor from x with labels “good”, “neutral” and “bad”. Create a character vector x with two repetitions of the vector c(“never-smoker”, “ex-smoker”, “current-smoker”), and then define a factor from x. Is the ordering of levels good enough? Redefine the factor with a better ordering. Create two Date objects: one with today’s date, and the other with your date of birth. Then, use these objects to: Compute your age in days Compute your age in (whole) years Print your date of birth, including the weekday the full name of the month and the year with four digits When fixed = FALSE (the default value), this is interpreted as a regular expression; regular expressions are a powerful way to manipulate strings, but are out of the scope of this book.↩︎ This and other statistical tests will be introduced in future chapters. Our purpose here is to show how the results of statistical tests are organized, not their meaning.↩︎ "],["data-acquisition.html", "3 Data Acquisition 3.1 Reading MS Excel data 3.2 Reading text data 3.3 Reading SPSS, SAS or Stata data 3.4 Reading databases 3.5 Reading other formats 3.6 Getting data from R packages 3.7 Problems when importing data from external files Resources Exercises", " 3 Data Acquisition Data acquisition is the process of importing data into your R session, so that it can be viewed and analyzed. There are several ways in which you can get data, but the usual case is to read an external data file. Common data file formats are Excel, plain text, SPSS, SAS or Stata data files. It is very easy to read files in these file formats by clicking the Import Dataset button of the Evironment pane in RStudio; this will unfold a list of file formats, and you just need to select the appropriate one. Upon selection, a new window will show-up from which we can pick the data file and provide information on how to read it. This information is partially different depending on the format, and in the following sections we show how to proceed in each case. 3.1 Reading MS Excel data In the Import Dataset button of the Evironment pane of RStudio, select From Excel..., and you will be presented with a dialog like the one in figure 3.1. Figure 3.1: Dialog to read Excel files The File/URL box at the top of this dialog is where we should write the Excel file address. If the data file is located in you computer, you can pick it using the (top-right) Browse button. If the Excel file is somewhere in the internet, you can write (or paste) the URL in the box. As soon as you pick the file (or write its URL), you will see the result of a default reading in the Data Preview box. You should always look at the result of the reading in the Data Preview to ensure that you get what you want. In some cases, the default reading will be enough, but in some others you will realize that there is some problem. Then, you can use the Import options as appropriate: Name: to provide a name for the resulting dataframe; this is automatically filled but you can change it to any valid name. Sheet: to indicate the sheet you want to read (if there is more than one sheet in the Excel file). Range: to indicate the range of cells to read, in standard Excel syntax (e.g., B3:F51). Max rows: to indicate the maximum number of rows you want to read (may be handy for test-reading of very large files). Skip: to start reading data after skipping the indicated number of rows. NA: to define the character(s) used in the Excel file to represent missings. First row as names: check if the first row that will be read contains column names. Open data viewer check to open the resulting dataframe in a new tab at the top-left RStudio pane. Last, the Code preview box shows the R code that will be executed when you click the Import button. 3.2 Reading text data There are two entries in the list under the Import Dataset for reading text data: From Text (base) and From Text (readr). We recommend the later, which opens the dialog of figure 3.2. Figure 3.2: Dialog to read text files Some of the Import options are similar to those commented in the previous section for Excel files (Name, Skip and First Row as Names, NA, Open Data Viewer), but the following are specific of text data files: Trim spaces: to trim leading and trailing white spaces for each data point Delimiter: to define what is used to separate data points Quotes: to indicate the type of quotes used for texts (if any) Locale: to indicate the configuration of locale settings, such as the decimal mark, the thousands separator, or the time zone. Escape: does the file use backslash to escape special characters? or does the file escape quotes by doubling them? Comment: to indicate the symbol used in the file for comments (that should be ignored) Before reading a text data file, it is very important to inspect how the data are arranged. This can be done by opening the file with any text editor, like the Notepad in Windows, or with RStudio (using the menu File &gt; Open file...). For instance, figure 3.3 shows a text data file containing variable names in the first row, where data are delimited by tabs, texts are unquoted, and the dot is used as the decimal separator. Figure 3.3: Text data file (delim: tab) As a second example, the text data file shown in figure 3.4 also contains variable names in the first row, but data are delimited by semicolons, texts are quoted (with double quotes), and uses the dot as the decimal separator. Figure 3.4: Text data file (delim: semicolon) 3.3 Reading SPSS, SAS or Stata data The dialog opened by options From SPSS, From SAS and From Stata are very similar. In figure 3.5 we show the former, where there is only one active Input Option refering to the input data file: Format: to specify the type of SPSS file (default: .SAV) Figure 3.5: Text data file (delim: semicolon) 3.4 Reading databases There are many different database management systems (DBMS) that are widely used, like MySQL, PostgreSQL, Microsoft Access and SQL Server, Oracle, or Sqlite. To read a database (DB) with R we need to establish a connection to the the DB, either using specific drivers provided by the BD vendor, or using open DB connectivity (ODBC), a way to access any SQL-based DBMS which is implemented in the R package RODBC In the following tutorial we show how to connect to a Microsoft Access DB, using the RODBC package. It is important to note that this will only work when your are using 32-bits R to read 32-bits DB drivers. After installing and loading the RODBC package, a connection is established to the Access DB with function odbcConnectAccess(). Then, the sqlTables() function is used to get a list of all tables in the DB. To get a specific table from the DB we use function sqlFetch(). It is important to close the connection when the job is done. library(RODBC) con &lt;- odbcConnectAccess(&quot;./data/demo.mdb&quot;) # establish connection to the DB sqlTables(con) # print table-like objects in the DB d &lt;- sqlFetch(con, &quot;demo&quot;) # gets the table demo d class(d) # the result is a dataframe close(con) # don`t forget to close the connection! rm(con) # before removing it!! 3.5 Reading other formats Besides the facilities described in previous sections to read common data file formats from RStudio, many other file formats can be read with R. These are some of them: PDF files can be read with package pdftools (see this example). HTML, XML: there are several packages to work with HTML and XML files, but package xml2 can be use to read both (see here). JSON files can be read with package rjson (see this tutorial). Web pages: the rvest package, is useful for webscraping (getting data from web pages) (see this tutorial). There are several packages that can be used to read/write and visualize geospatial data (maps) (see this CRAN Task View). There are several packages to read/write and visualize medical images in formats DICOM, NALYZE or NIfTI-1 (see this CRAN Task View for more info). Genetic data can be imported from a wide range of formats, including those of popular population genetics software (GENETIX, STRUCTURE, Fstat, Genepop) with package adegenet (see here for more info). This list is by no means comprehensive. If you are interested in reading a particular file format not covered here, it is very likely you will find useful info by Googleing “R (format_name)”. 3.6 Getting data from R packages Many R packages contain example data sets. In the base installation of R you will find thedatasets package (look for it in the Packages tab of RStudio, and click on the name of the package) that contains many example datasets. However, only a few are related to clinical research (e.g., the Indometh dataset). A (non-comprehensive) list of clinical datasets contained in R packages can be found here. To work with any of these datasets you need to install the corresponding package, and then look at the help of the dataset. For instance, the MASS package includes the birthwt dataset. The following script prints its first rows with head() (six rows are printed by default, but you could indicate a different number in a second argument): head(MASS::birthwt) # this will print the first 6 rows low age lwt race smoke ptl ht ui ftv bwt 85 0 19 182 2 0 0 0 1 0 2523 86 0 33 155 3 0 0 0 0 3 2551 87 0 20 105 1 1 0 0 0 1 2557 88 0 21 108 1 1 0 0 1 2 2594 89 0 18 107 1 1 0 0 1 0 2600 91 0 21 124 3 0 0 0 0 0 2622 For a brief description of the data, look at the help after loading the package by running ?birthwt. Since the beginning of the COVID-19 pandemics, several resources have been developed with R, including R packages (see a list here). Among them, the COVID19 package provides a unified dataset by collecting worldwide fine-grained case data that can be easily extended with World Bank Open Data, Google Mobility Reports, and Apple Mobility Reports (see this short tutorial). In addition, some R packages provide more or less easy access to many different databases of interest for clinical researchers, such as the following: rentrez is a package for retrieving data from the National Center for Biotechnology Information (NCBI), including PubMed and GenBank. rclinicaltrials provides an interface to ClinicalTrials.gov, a registry and results database of clinical studies conducted around the world. nhanesA allows retrieval of data from the National Health and Nutrition Examination Survey (NHANES) conducted by the National Center for Health Statistics (NCHS). WHO allows to download public health data from the World Health Organization’s Global Health Observatory. wbstats provides access to the World bank data, a comprehensive source of global socio-economic data. Some additional R packages to access open public health data are commented in this post. 3.7 Problems when importing data from external files It is very common to have problems when reading real-life data, especially when data have been entered manually performing no validation. This is often the case when data are entered in Excel spreadsheets (though Excel has some data validation tools, these are ignored by many users). Some of the most frequent problems are: Inadequate variable names Incorrect reading of numeric data Incorrect reading of dates In this section we show how to deal with these problems using the dplyrpackage, which is very convenient to work with dataframes. 3.7.1 Package dplyr Before proceeding, you should install and load the dplyrpackage: library(dplyr) The dplyr package provides several functions to perform common tasks, and function names are verbs describing the task they perform. Some of these functions are: select(): selects variables from a dataframe (and optionally renames them) filter(): filters rows of a dataframe according to some logical condition mutate(): creates new variables in a dataframe rename(): renames variables in a dataframe arrange(): changes the ordering of the rows of a dataframe The first argument to all these (and other) dplyr functions is a dataframe, and all of them provide a dataframe as a result. Each function takes other function-specific arguments. Table 3.1 shows some examples of use of these functions with a description of the result they produce. In these examples, we assume that d is a dataframe containing variables sex, age, race, weight (in kilograms) and height (in centimeters). Table 3.1: Example of dplyr function calls Function call Result: a dataframe with… select(d, sex, age, race) all rows in d, and variables sex, age, race. select(d, gender=sex, age, race) all rows in d, and variables gender, age, race. filter(d, sex == \"male\") males in d, and all variables. rename(d, gender = sex) all rows in d, and variables gender, age, race, weight, height. mutate(d, height_meters = height/100) all rows and variables in d, plus new variable height_meters arrange(d, age) all rows and variables in d, with rows sorted by To note in the examples of table 3.1: variable names are neither prefixed with the dataframe name, nor quoted. a double equal sign is used to specify equality conditions, as in filter(d, sex == \"male\"). a single equal sign (instead of the assignment operator &lt;-), is used to define new variables with mutate(), as in mutate(d, height_meters = height/100). When you load the dplyr package, you can use the so called pipe operator (%&gt;%). As you will see soon, this allows to chain operations in a very practical way. The basic usage of the pipe is shown in table 3.2: Table 3.2: Usage of the pipe with dplyr functions This is equivalent… to this select(d, sex, age, race) d %&gt;% select(sex, age, race) filter(d, sex == \"male\") d %&gt;% filter(sex==\"male\") mutate(d, height_meters = height/100) d %&gt;% mutate(height_meters = height/100) arrange(d, age) d %&gt;% arrange(age) This works because d is the first argument of select(), filter(), mutate() and arrange(). You can use this operator with any function (not just with functions from dplyr), provided that the object before %&gt;% is the first argument of the function after %&gt;%. Table 3.3 shows a basic usage of the pipe with base R functions (in the first example we assume d is some existing dataframe): Table 3.3: Usage of the pipe with base R functions This is equivalent… to this names(d) d %&gt;% names() round(2.38, 1) 2.38 %&gt;% round(1) log(100) 100 %&gt;% log() What is really powerful about the pipe operator is that you can chain as many operations as you wish, provided you stick to the rule: what goes before %&gt;% is the first argument of the function after %&gt;%. For instance, the following two expressions are equivalent: round(log(100), 4) # nested functions [1] 4.6052 100 %&gt;% log() %&gt;% round(4) # chained functions [1] 4.6052 Notice that it is much more difficult to write the first of these expression: while you think “compute the log of 100 and round the result to four decimals”, nesting functions requires you to work from the inside out. However, when chaining operations with the pipe you follow the natural order of operations: “take 100, then compute the log, then round to four decimals”. As you see, each pipe can be read as then, or more precisely, then do whatever the next function indicates, taking the previous result as its first argument. Chaining can be applied to dataframe operations as well, as in the following example: take d, then filter males, then compute the height in meters, and then select the two height variables. # creating an example dataframe d &lt;- data.frame(sex = rep(c(&quot;male&quot;, &quot;female&quot;), 3), age = c(19, 23, 45, 38, 57, 61), height = c(180, 165, 174, 175, 168, 177)) # chaning operations with the pipe (%&gt;%) d %&gt;% filter(sex == &quot;male&quot;) %&gt;% mutate(height_meters = height/100) %&gt;% select(height, height_meters) height height_meters 1 180 1.80 2 174 1.74 3 168 1.68 We have only scraped the surface of the dplyr package, and there is much more power in it for dataframe operations. But what we covered should be enough to start using it as we do in the following section. 3.7.2 Reading the SARA data To illustrate problems that appear quite often when reading a real dataset, we will use a simplified version of the data collected in the SARA trial. This was a randomized clinical trial that compared catheter ablation vs. antiarrhythmic drug treatment in patients with persistent atrial fibrillation. The data has been modified in several ways for didactic purposes, and therefore the results shown here may differ from those described in the paper. You can download this file from here. We first read the dataset, and inspect variable names: library(readxl) raw_data &lt;- read_excel(&quot;data/SARA_simplified.xlsx&quot;) names(raw_data) [1] &quot;Patient no&quot; &quot;Birth Date (yyyymm-dd)&quot; [3] &quot;Sex&quot; &quot;Date of randomization&quot; [5] &quot;Random allocation of Treatment&quot; &quot;Body Weight at baseline (kg)&quot; [7] &quot;Body Height at baseline (cm)&quot; &quot;NYHA classification at baseline&quot; [9] &quot;SBP at baseline (mmHg)&quot; &quot;DBP at baseline (mmHg)&quot; [11] &quot;Heart Rate at baseline (bpm)&quot; The variable names contain blank spaces and some special characters like brackets, and are too long. We better clean them using function clean_names() from the janitor package, and revise the result: library(janitor) d &lt;- clean_names(raw_data) # clean variable names names(d) # review [1] &quot;patient_no&quot; &quot;birth_date_yyyymm_dd&quot; [3] &quot;sex&quot; &quot;date_of_randomization&quot; [5] &quot;random_allocation_of_treatment&quot; &quot;body_weight_at_baseline_kg&quot; [7] &quot;body_height_at_baseline_cm&quot; &quot;nyha_classification_at_baseline&quot; [9] &quot;sbp_at_baseline_mm_hg&quot; &quot;dbp_at_baseline_mm_hg&quot; [11] &quot;heart_rate_at_baseline_bpm&quot; Note that spaces have been replaced with underscores, and special character like brackets have been eliminated. This function made a good job, and in many instances the result will be good enough to proceed. In this case however, variable names are too long, so we rename them using the rename() function of dplyr: d &lt;- rename(d, # rename vars patient = patient_no, birth_dt = birth_date_yyyymm_dd, rand_dt = date_of_randomization, group = random_allocation_of_treatment, weight = body_weight_at_baseline_kg, height = body_height_at_baseline_cm, nyha = nyha_classification_at_baseline, sbp = sbp_at_baseline_mm_hg, dbp = dbp_at_baseline_mm_hg, hr = heart_rate_at_baseline_bpm) names(d) # review [1] &quot;patient&quot; &quot;birth_dt&quot; &quot;sex&quot; &quot;rand_dt&quot; &quot;group&quot; &quot;weight&quot; [7] &quot;height&quot; &quot;nyha&quot; &quot;sbp&quot; &quot;dbp&quot; &quot;hr&quot; Much better. Now, let’s have a first look at the data by printing the first rows of the dataframe: head(d) # prints first six rows # A tibble: 6 × 11 patient birth_dt sex rand_dt group weight height nyha sbp &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 00:00:00 1 11/05/2009 Cathet… 104 188 1 110 2 1-002 1970-02-27 00:00:00 1 12/05/2009 Antiar… 92 182 1 NA 3 1-003 1964-02-21 00:00:00 2 11/06/2009 Cathet… 95 177 1 125 4 1-004 1962-01-04 00:00:00 2 20/07/2009 Cathet… 80 162 1 139 5 1-005 1974-06-02 00:00:00 1 17/08/2009 Antiar… 93 175 NA 122 6 1-006 1964-06-22 00:00:00 1 21/09/2009 Cathet… 115 185 1 120 # … with 2 more variables: dbp &lt;dbl&gt;, hr &lt;dbl&gt; In the previous output, the header of each data frame column includes the variable name and the type of data is indicated with abbreviations: &lt;chr&gt; for character, &lt;dttm&gt;for datetime, and &lt;dbl&gt; for double (which is a type of numeric). The following is to note: birth_dt is a datetime object, but time values are 00:00:00, and we want it to be a Date object anyway. rand_dt is character, but we want it to be Date as well. weight is character, but we expected a numeric. But let’s verify the object classes of these three variables: class(d$birth_dt) [1] &quot;POSIXct&quot; &quot;POSIXt&quot; class(d$rand_dt) [1] &quot;character&quot; class(d$weight) [1] &quot;character&quot; Yes, these objects classes are as indicated by the abbreviations in the output above. The problem with weightdeserves some investigation. When a variable containing digits is not recognized as numeric, it is likely due to some value(s) containing forbidden characters for numeric data. To verify this, we use mutate() to create a numeric version of weight with as.numeric(), and then filter the rows where the numeric version is missing but the original weight is not. Last, we select() the patient number and the two versions of weight, and we store the resulting dataframe as commas for future reference: commas &lt;- d %&gt;% mutate (weight_numeric = as.numeric(weight)) %&gt;% filter(is.na(weight_numeric) &amp; !is.na(weight)) %&gt;% select(patient, weight, weight_numeric) commas # A tibble: 9 × 3 patient weight weight_numeric &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 1-034 67,2 NA 2 1-052 84,5 NA 3 1-053 99,5 NA 4 2-022 92,5 NA 5 6-002 85,5 NA 6 6-013 83,5 NA 7 7-003 85,5 NA 8 7-008 91,5 NA 9 7-014 92,5 NA There are nine patients with decimals in weight that could not be interpreted as numbers because the comma (instead of a dot) was used as decimal separator. Now we need to replace this commas with dots, and this can be done with function sub(). Once the decimal separator problem has been fixed, we can safely convert to numeric. Last, we filter patients in commas to verify the result. d %&gt;% mutate(weight_fixed = sub(pattern = &quot;,&quot;, replacement = &quot;.&quot;, x = weight, fixed=TRUE), weight_numeric = as.numeric(weight_fixed)) %&gt;% select(patient, weight, weight_fixed, weight_numeric) %&gt;% # filter patients filter(patient %in% commas$patient) # A tibble: 9 × 4 patient weight weight_fixed weight_numeric &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 1-034 67,2 67.2 67.2 2 1-052 84,5 84.5 84.5 3 1-053 99,5 99.5 99.5 4 2-022 92,5 92.5 92.5 5 6-002 85,5 85.5 85.5 6 6-013 83,5 83.5 83.5 7 7-003 85,5 85.5 85.5 8 7-008 91,5 91.5 91.5 9 7-014 92,5 92.5 92.5 Note in the script above we have defined two new variables in the mutate() function call (weight_fixed and weight_numeric), separated by comma. Moreover, note that the second variable is defined from the first. This means that, in a single call of mutate(): we can define as many new variables as needed (comma separated), and new variables are immediately available once defined We are left with the problem of dates. This can be fixed with function as.Date(): d %&gt;% mutate(birth_dt = as.Date(birth_dt), rand_dt = as.Date(rand_dt, &quot;%d/%m/%Y&quot;)) # A tibble: 152 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 1 2009-05-11 Catheter… 104 188 1 110 70 2 1-002 1970-02-27 1 2009-05-12 Antiarrh… 92 182 1 NA NA 3 1-003 1964-02-21 2 2009-06-11 Catheter… 95 177 1 125 70 4 1-004 1962-01-04 2 2009-07-20 Catheter… 80 162 1 139 63 5 1-005 1974-06-02 1 2009-08-17 Antiarrh… 93 175 NA 122 74 6 1-006 1964-06-22 1 2009-09-21 Catheter… 115 185 1 120 80 7 1-007 1950-06-30 1 2009-10-01 Catheter… 89 177 1 126 102 8 1-008 1955-03-29 1 2009-10-06 Catheter… 77 178 1 NA NA 9 1-009 1941-07-25 2 2009-11-10 Antiarrh… 62 162 1 140 85 10 1-010 1955-04-22 1 2009-11-17 Antiarrh… 86 168 1 122 83 # … with 142 more rows, and 1 more variable: hr &lt;dbl&gt; Finally, we can perform all the operations we have done by chaining them with pipes, so that we do everything in a single code chunk. This is done in the following script. Note that in this case the problem with commas in weight has been fixed in a single step, and the result overwrites the weight variable, to avoid additional variables in the dataframe. library(readxl) library(janitor) library(dplyr) d &lt;- read_excel(&quot;data/SARA_simplified.xlsx&quot;) %&gt;% # reads data clean_names() %&gt;% # for well formed names rename(patient = patient_no, # for shorter names birth_dt = birth_date_yyyymm_dd, rand_dt = date_of_randomization, group = random_allocation_of_treatment, weight = body_weight_at_baseline_kg, height = body_height_at_baseline_cm, nyha = nyha_classification_at_baseline, sbp = sbp_at_baseline_mm_hg, dbp = dbp_at_baseline_mm_hg, hr = heart_rate_at_baseline_bpm) %&gt;% mutate(weight = as.numeric(sub(pattern = &quot;,&quot;, # commas to dots, replacement = &quot;.&quot;, # and convert to x = weight, # ...numeric fixed=TRUE)), birth_dt = as.Date(birth_dt), # convert to Date rand_dt = as.Date(rand_dt, &quot;%d/%m/%Y&quot;)) d # A tibble: 152 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 1 2009-05-11 Catheter… 104 188 1 110 70 2 1-002 1970-02-27 1 2009-05-12 Antiarrh… 92 182 1 NA NA 3 1-003 1964-02-21 2 2009-06-11 Catheter… 95 177 1 125 70 4 1-004 1962-01-04 2 2009-07-20 Catheter… 80 162 1 139 63 5 1-005 1974-06-02 1 2009-08-17 Antiarrh… 93 175 NA 122 74 6 1-006 1964-06-22 1 2009-09-21 Catheter… 115 185 1 120 80 7 1-007 1950-06-30 1 2009-10-01 Catheter… 89 177 1 126 102 8 1-008 1955-03-29 1 2009-10-06 Catheter… 77 178 1 NA NA 9 1-009 1941-07-25 2 2009-11-10 Antiarrh… 62 162 1 140 85 10 1-010 1955-04-22 1 2009-11-17 Antiarrh… 86 168 1 122 83 # … with 142 more rows, and 1 more variable: hr &lt;dbl&gt; And that’s it, at least by now! Resources A comprehensive tutorial on R data import (including some formats we have not mentioned) can be found here. Data Import Cheat Sheet For more information on the use of package janitor, see this tutorial. For more information on the use of package dplyr, see this tutorial. To easily read many different data formats with a single function, see this introduction to the rio package. Exercises Download this Excel file and read it using the Import Dataset button in the Environment pane of RStudio. How many variables are in the resulting dataframe, and what are their names? Get well formed names with function clean_names() of package janitor. Download this Excel file and read it using the Import Dataset button in the Environment pane of RStudio. How many variables are in the resulting dataframe, and what are their names? Give appropriate names to the dataframe variables. Read this text data file. Why do you think the Weight variable is read as character vector? Look at the character used for missings. Can you imagine a way to read this correctly, so that Weight is a numeric vector? (Hint:explore changing the NA Import Optionto NA, and look at the Code Preview; maybe if you copy this code to the editor you can adapt it to indicate that the NA symbol is…). Read this text file. Are the names of the countries properly written? Try to use the Locale Import Option to set the Encoding to “ISO-8859-1”. Download this SPSS file and read it using the Import Dataset button in the Environment pane of RStudio. What is the class of the Sex variable in the resulting demo dataframe?. Now run this code d &lt;- as_factor(demo). What is the class of Sex in d? Read the Nobel Price Laureates dataset with RStudio and list the variable names of the resulting laureate dataframe. Then, use janitor::clean_names() to get a dataframe with better names, and save it as d. With d, do the following: Look at the class of variables born and died. If not Date, convert this variables to standard dates. Nobel Laureates are awarded the Nobel prize in a ceremony held the 10 December every year, on the anniversary of Alfred Nobel’s death. Use paste() to build a character vector containing the dates the laureates were awarded the prize. Convert the previous result to a Date object and use it to compute the age each laureate was awarded the Nobel Prize. Filter laureates for the “medicine” category and save the resulting dataframe as medicine. Use count(medicine, born_country) to get the number of medicine laureates per country of birth; look at the help of count() to see how to get the result sorted by frequency. Use the same function to get the number of medicine laureates per name, and then filter institutions with more than one laureate. Filter medicine to see the laureates that, when awarded the prize, where working in a country different from their born_country. How many of them were in a different country? "],["data-preparation.html", "4 Data preparation 4.1 Steps in data preparation 4.2 Reading raw data 4.3 Reviewing data 4.4 Modifying data 4.5 Computing new variables 4.6 Selecting valid cases 4.7 Saving the R script Resources Exercises", " 4 Data preparation Data preparation is the process by which we generate tidy data from raw data. Raw data is the original version of the data as stored during collection, whatever its source, format, structure and state. It is very common that raw data need some tweaks to make them ready for statistical analysis. These tweaks may involve simplifying the data structure, providing appropriate labels for coded variables, detecting and amending errors, recovering missing data, or computing new variables from those available. Tidy data is what we get after these tweaks: a version of the data ready for analysis. For a set of data to be considered tidy it should have the following structure: Each variable is a column in a dataframe Each observation is a row in a dataframe Each type of observational unit is a dataframe For instance, suppose we conducted a study on 100 patients and collected data on demographic and anthopometric variables age, sex, and body height and weight. The observational unit is then the patient, and these data can be arranged in a dataframe, having columns for patient, age, sex, height and weight, so that all data for one patient fits in a single row (see table 4.1). Table 4.1: Demographic and anthropometic data patient age sex height weight 1 67 male 180 91 2 42 male 168 75 3 39 female 176 69 4 … … … … 5 … … … … Now consider data on vital signs such as pulse, systolic and diastolic blood pressure, taken in three visits for the same set of patients. In this case, the observational unit is not the patient, but the visit of a patient, and data should be stored in a dataframe having patient, visit, temperature, pulse, systolic and diastolic blood pressure as columns, so that all data of one visit (of a given patient) fits in one row (see table 4.2). Table 4.2: Vital signs patient visit pulse sbp dbp 1 1 77 120 85 1 2 85 145 90 1 3 69 110 65 2 1 70 120 85 2 2 80 135 85 2 3 … … … 3 1 … … … Last, consider data on adverse events collected during a clinical trial. For each event, some characteristics are recorded, such as the duration(days), severity, actions taken, and outcome. In this case, the observational unit is the adverse event, and the data should be stored in a dataframe with columns patient, event, start date and stop date, severity, actions taken, and outcome. Again in this case, all data for an event fits in a single row (see table 4.3. Table 4.3: Adverse events patient visit event duration actions outcome 1 1 Headache 1 none recovered 2 1 Nausea 2 none recovered 2 2 Vomiting 1 none recovered 2 3 Abdominal cramps 1 none recovered 3 1 Hip fracture 1 surgery recovered 3 2 … … … … 4 1 … … … … You will note that the dataframe of figure 4.1 will have as many rows as patients in the study, that is, one-hundred. However, the dataframe of figure 4.2 will have three rows per patient, therefore totaling three-hundred rows (assuming all patients were visited three times). Last, the number of rows in the dataframe of figure 4.3 cannot be known in advance, because a patient can experience no AE at all, one AE or many AE. It should be clear that the structure of these three dataframes is different, and that is why we need three dataframes to accommodate all the data. Trying to put all of it in a single dataframe would result in undesirable things, such as having different columns containing the same type of data (such as AE1, AE2, AE3, …), and structural missings (AE2, AE3, … will be missing for patients experiencing just one AE, but this missings do not reflect lack of data, and are only due to an inappropriate data structure). For the sake of simplicity, in this chapter we will be concerned with the case where all the available data can be stored in a single dataframe having the simplest possible structure, just like the one in figure 4.1. If this is the case, each row will correspond to a patient, and each column to a variable. This should be enough for many simple observational studies collecting a limited amount of data on a single time point. But even in this simple case, it is important to have a unique case identifier; this is always convenient, and it is critical when the data has to be split in different dataframes, to allow record linkage. In any case, it is good practice to create dataframes with the following additional characteristics: Variable names should be short but meaningful, and should contain neither spaces, nor non-standard characters (like slashes, or accents in Spanish words). Variable names may follow different styles, like CAPITALIZED, camelCase, or snake_case, but whatever the style, consistency is a plus. In these book we use the snake_case style. Categorical variables should have meaningful levels (e.g., “male” or “female” rather than 1 or 2, or “m”, or “f”), and should be factors rather than character vectors. Quantitative variables should have the units of measurement documented somewhere, though not necessarily in the variable name (in fact this is not recommended, to keep variable names as short as possible, and free of special characters such as brackets, slashes or Greek letters); the study protocol is a reasonable place to document variable units. A minimal information on the study design, or on how the data were collected, should be available somewhere (e.g., in the study protocol). It is very important that the data preparation process is traceable and reproducible. To ensure traceability and reproducibility, this process should be done programmatically rather than manually. Manual editions of the data are not reproducible (unless very well documented, which takes a lot of time and is prone to errors), and should be avoided. In this chapter we will see what are the most common tasks in data preparation and how to accomplish them following this principle by writing R scripts. 4.1 Steps in data preparation It is convenient to approach data preparation in a systematic way. The following is a reasonable order of the most common data preparations tasks: Reading raw data Reviewing data (looking for problems: missings and errors) Modifying data (to fix problems) Computing new variables Selecting valid cases Saving the R script performing steps 1 to 5 above All the data preparation tasks in steps 2 to 5 above, no matter how complex, can be accomplished using base R. However, some of them are easier using the dplyr package introduced in the previous chapter, and this is the approach we will follow, with few exceptions. 4.2 Reading raw data Reading external data files was addressed in the previous chapter, where we read the SARA data with the following script: library(readxl) library(janitor) library(dplyr) d &lt;- read_excel(&quot;data/SARA_simplified.xlsx&quot;) %&gt;% clean_names() %&gt;% rename(patient = patient_no, birth_dt = birth_date_yyyymm_dd, rand_dt = date_of_randomization, group = random_allocation_of_treatment, weight = body_weight_at_baseline_kg, height = body_height_at_baseline_cm, nyha = nyha_classification_at_baseline, sbp = sbp_at_baseline_mm_hg, dbp = dbp_at_baseline_mm_hg, hr = heart_rate_at_baseline_bpm) %&gt;% mutate(weight = as.numeric(sub(pattern = &quot;,&quot;, replacement = &quot;.&quot;, x = weight, fixed=TRUE)), birth_dt = as.Date(birth_dt), rand_dt = as.Date(rand_dt, &quot;%d/%m/%Y&quot;)) head(d) # A tibble: 6 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 1 2009-05-11 Catheter … 104 188 1 110 70 2 1-002 1970-02-27 1 2009-05-12 Antiarrhy… 92 182 1 NA NA 3 1-003 1964-02-21 2 2009-06-11 Catheter … 95 177 1 125 70 4 1-004 1962-01-04 2 2009-07-20 Catheter … 80 162 1 139 63 5 1-005 1974-06-02 1 2009-08-17 Antiarrhy… 93 175 NA 122 74 6 1-006 1964-06-22 1 2009-09-21 Catheter … 115 185 1 120 80 # … with 1 more variable: hr &lt;dbl&gt; We will use this d dataframe to illustrate the data preparation tasks covered in this chapter. 4.3 Reviewing data Data review is a must with any real data set. You cannot assume your data is free of errors. Rather, you should assume that data has errors unless you prove otherwise. The very first test of a dataset should be to verify that the unique case identifier is really unique, i.e., that all patients have a different value in this variable. The unique() function applied to a vector returns all distinct values with no repetitions (if any). Then, the length() of the resulting vector will be the number of distinct values, and this can be compared to the number of patients (rows) in the dataset: length(unique(d$patient)) # number of distinct values in d$patient [1] 152 length(unique(d$patient)) == nrow(d) # is it equal to the number of rows in d? [1] TRUE Now we are sure that there are no two patients with the same case identifier (otherwise the previous comparison would have produced a FALSE). 4.3.1 Missings Because missing data is a very common problem in real life datasets, we should always start by looking at the number of missings in the data. There are several functions for this purpose, but the simplest one is the base R function is.na(). In previous chapters we used this function on a vector, and summed the result to get the number of missings: sum(is.na(d$weight)) # missings in weight [1] 19 Interestingly, we can use is.na() with dataframes as well. In this case, the result will be a matrix of logical values, the columns (and rows) of which correspond to the columns (and rows) of the dataframe. The colSums() function applied to this matrix will result in the number of missings for each column in the original dataframe. By nesting both functions, a single line of code is enough to get the number of missings in each variable of a dataframe, as shown below (you can do it in two steps if you want to see the matrix produced by is.na(d)) colSums(is.na(d)) # missings in columns of d patient birth_dt sex rand_dt group weight height nyha 0 0 0 0 0 19 22 2 sbp dbp hr 14 14 0 Another option is provided by the plot_missing() function in package DataExplorer, showing the number (and percentage) of missings for each variable in a graphic: DataExplorer::plot_missing(d) 4.3.2 Data errors Errors in the data are very common, and we should attempt to detect at least gross errors before proceeding with the analysis. Error detection may be easy or very difficult depending on the type of variable and the type of error. Gross errors in numeric variables and dates can be easily detected by looking at their extreme values (minimum and maximum). These (among other statistics) are provided by summary() for each numeric variable in a dataframe: summary(d) patient birth_dt sex rand_dt Length:152 Min. :1939-06-24 Min. : 1.000 Min. :2009-05-07 Class :character 1st Qu.:1949-11-09 1st Qu.: 1.000 1st Qu.:2010-01-17 Mode :character Median :1954-03-30 Median : 1.000 Median :2010-08-25 Mean :1955-11-06 Mean : 1.362 Mean :2010-08-27 3rd Qu.:1962-01-01 3rd Qu.: 1.000 3rd Qu.:2011-03-22 Max. :1983-06-22 Max. :22.000 Max. :2011-11-24 group weight height nyha Length:152 Min. : 50.00 Min. : 83.0 Min. :1.00 Class :character 1st Qu.: 74.00 1st Qu.:165.0 1st Qu.:1.00 Mode :character Median : 84.50 Median :174.0 Median :1.00 Mean : 85.75 Mean :172.0 Mean :1.26 3rd Qu.: 95.00 3rd Qu.:179.8 3rd Qu.:1.00 Max. :167.00 Max. :193.0 Max. :3.00 NA&#39;s :19 NA&#39;s :22 NA&#39;s :2 sbp dbp hr Min. :100.0 Min. : 60.00 Min. : 4.00 1st Qu.:119.2 1st Qu.: 70.00 1st Qu.: 57.00 Median :127.0 Median : 80.00 Median : 66.00 Mean :127.4 Mean : 80.42 Mean : 71.14 3rd Qu.:137.0 3rd Qu.: 87.00 3rd Qu.: 82.00 Max. :197.0 Max. :110.00 Max. :150.00 NA&#39;s :14 NA&#39;s :14 In the previous output we see the maximum value of sex is 22, which is an obvious error. There is also a suspicious maximum of 167 (kg) in weight, a very suspicious minimum of 83 (cm) in height, and an impossible minimum heart rate (hr) of 4 (bpm). However, the previous output is not useful for the group variable, and this is because it’s a character vector. The result would be useful if group was a factor (we would then see each possible value and its frequency), but we have not defined factors yet. Note that summary() also provides information on the number of missings (NA's). We can inspect the values of a categorical variable stored in a character vector using unique(). This will print all distinct values appearing in the vector, without repetitions: unique(d$group) [1] &quot;Catheter ablation&quot; &quot;Antiarrhythmic drug treatment&quot; unique(d$sex) # useful for coded categorical variables as well [1] 1 2 22 unique(d$nyha) [1] 1 NA 2 3 Sometimes it is worth looking at a graphic combining two variables whose values are related. For instance, we may look at the join distribution of weightand height as done in figure 4.1 (these and other graphics will be presented in detail in the next chapter). Figure 4.1: Weight and height By looking at this figure we confirm the weight value 167 kg is an error, since it corresponds to the patient with the minimum height value of 83 cm. This error is likely due to a permutation of heigh and weight values for this patient, which is a common data entry error. Interestingly, there is another patient showing an unusual combination of weight (125 kg) and height (about 160 cm). Though these values have nothing strange when we consider them separately, their combination is unlikely. For this reason, this error was not detected when we looked at these variables separately by inspecting their extreme values, but are easily detected in the plot above. Once we have detected problematic values in our data, we need to investigate what are the patients affected by these errors. # Patients with errors d %&gt;% filter(sex == 22) %&gt;% select(patient, sex) # A tibble: 1 × 2 patient sex &lt;chr&gt; &lt;dbl&gt; 1 3-001 22 d %&gt;% filter(hr &lt; 40) %&gt;% select(patient, hr) # A tibble: 1 × 2 patient hr &lt;chr&gt; &lt;dbl&gt; 1 6-030 4 d %&gt;% filter(weight &gt; 124) %&gt;% select(patient, weight, height) # A tibble: 2 × 3 patient weight height &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; 1 4-001 167 83 2 5-007 125 158 # Patients with missings d %&gt;% filter (is.na(weight) | is.na(height) | is.na(nyha)| is.na(sbp) | is.na(dbp)) %&gt;% select(patient, weight: dbp ) # A tibble: 30 × 6 patient weight height nyha sbp dbp &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-002 92 182 1 NA NA 2 1-005 93 175 NA 122 74 3 1-008 77 178 1 NA NA 4 2-002 93 180 1 NA NA 5 2-003 93 179 1 NA NA 6 2-005 95 NA 2 120 70 7 2-016 65 158 1 NA NA 8 2-017 120 192 1 NA NA 9 3-004 70 175 NA 130 70 10 5-005 NA NA 1 135 75 # … with 20 more rows Now we should appeal to source documents (such as the clinical records) and try to recover the missing or erroneous data for these patients. 4.4 Modifying data Suppose we have recovered the following data from clinical records, and the remaining missing data could not be recovered: patient variable correct_value 1-005 nyha 1 3-004 nyha 1 3-001 sex 1 4-001 weight 83 4-001 height 167 6-030 hr NA To set these data points to their correct values it is very practical to use vector subsetting. When we subset a vector by a condition which is either TRUE or FALSE for each patient, the returned values are those for whom the condition is TRUE. Thus, if we subset a variable using a condition that identifies a single patient, we refer to the value of this variable for this patient. Note that we need to prefix the variable names with the dataframe names, since this is base R (not dplyr): d$sex[d$patient == &quot;3-001&quot;] # sex for patient 3-001 [1] 22 Then, we can use this to set a new value for this data point: d$sex[d$patient == &quot;3-001&quot;] &lt;- 1 # sex for patient 3-001 d$sex[d$patient == &quot;3-001&quot;] # verify [1] 1 In this manner, we can set all the remaining correct values: d$nyha[d$patient == &quot;1-005&quot;] &lt;- 1 d$nyha[d$patient == &quot;3-004&quot;] &lt;- 1 d$weight[d$patient == &quot;4-001&quot;] &lt;- 83 d$height[d$patient == &quot;4-001&quot;] &lt;- 167 d$hr[d$patient == &quot;6-030&quot;] &lt;- NA Finally, we can verify if everything went as expected by printing data for the patients we set new (correct) values. To filter these patients we use %in% operator, so that d rows will be filtered if the patient is one of those specified in the character vector after %in%. d %&gt;% filter(patient %in% c(&quot;1-005&quot;, &quot;3-001&quot;, &quot;3-004&quot;, &quot;4-001&quot;, &quot;6-030&quot;)) %&gt;% select(patient, sex, weight, height, nyha, hr) # A tibble: 5 × 6 patient sex weight height nyha hr &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-005 1 93 175 1 70 2 3-001 1 101 187 1 75 3 3-004 1 70 175 1 60 4 4-001 1 83 167 1 51 5 6-030 1 NA NA 1 NA It seems that everything is fine now! 4.5 Computing new variables Once all data problems are fixed, the next step is to define factors for all categorical variables, and to compute new variables derived from those in the data. Computing new variables may involve different type of operations, such as using computational formulas, making conditional assignments, categorizing a quantitative variable, recoding categorical variables or manipulating character strings. All these cases are very common, and are illustrated in the following sections. 4.5.1 Defining factors Dataframe d includes the following categorical variables: sex is a categorical variable coded as 1 (for males), or 2 (for females). nyha is a categorical variable coded with numbers 1 to 3 to represent NYHA classes I, II and III respectively. group is a a categorical variable stored as a character vector, with self-explanatory values but a bit too long to be practical (for example, when producing graphics, long strings are usually a problem); we can take the chance of defining a factor to shorten the descriptors as “CA” for Catheter ablation and “ADT” for Antiarrhythmic drug treatment. The following script defines factors for these three variables and overrides3 d with the result. d &lt;- d %&gt;% mutate(sex = factor(sex, levels = 1:2, labels = c(&quot;male&quot;, &quot;female&quot;)), nyha = factor(nyha, levels = 1:3, labels = c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;)), group = factor(group, levels = c(&quot;Catheter ablation&quot;, &quot;Antiarrhythmic drug treatment&quot;), labels = c(&quot;CA&quot;, &quot;ADT&quot;))) head(d) # A tibble: 6 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;fct&gt; &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 male 2009-05-11 CA 104 188 I 110 70 2 1-002 1970-02-27 male 2009-05-12 ADT 92 182 I NA NA 3 1-003 1964-02-21 female 2009-06-11 CA 95 177 I 125 70 4 1-004 1962-01-04 female 2009-07-20 CA 80 162 I 139 63 5 1-005 1974-06-02 male 2009-08-17 ADT 93 175 I 122 74 6 1-006 1964-06-22 male 2009-09-21 CA 115 185 I 120 80 # … with 1 more variable: hr &lt;dbl&gt; 4.5.2 Formulas Many derived variables are obtained using a computational formula involving arithmetic operations, mathematical functions, or both. For instance, the age of patients at randomization can be computed from the birth and randomization dates; the body mas index is computed from the body height and weight. These computations are easily implemented via mutate(), as in the following script, where we finish by selecting relevant variables to verify the result of the computations: d %&gt;% mutate(age = floor(as.numeric(rand_dt - birth_dt)/365.25), bmi = round(weight / (height/100)^2,1)) %&gt;% select(patient, rand_dt, birth_dt, age, weight, height, bmi) # A tibble: 152 × 7 patient rand_dt birth_dt age weight height bmi &lt;chr&gt; &lt;date&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 2009-05-11 1974-11-15 34 104 188 29.4 2 1-002 2009-05-12 1970-02-27 39 92 182 27.8 3 1-003 2009-06-11 1964-02-21 45 95 177 30.3 4 1-004 2009-07-20 1962-01-04 47 80 162 30.5 5 1-005 2009-08-17 1974-06-02 35 93 175 30.4 6 1-006 2009-09-21 1964-06-22 45 115 185 33.6 7 1-007 2009-10-01 1950-06-30 59 89 177 28.4 8 1-008 2009-10-06 1955-03-29 54 77 178 24.3 9 1-009 2009-11-10 1941-07-25 68 62 162 23.6 10 1-010 2009-11-17 1955-04-22 54 86 168 30.5 # … with 142 more rows We computed the age of patients as the difference of the randomization and birth dates (which results in a number of days) divided by 365.25 to take into account leap years, and then used floor() to round down so as to get completed years. The body weigh (kg/m^2) is defined as weight in kilograms over the square of height in meters. Because height is expressed in centimeters, we divided by 100 to convert it to meters before squaring. 4.5.3 Conditional assignments Computational formulas are applied exactly the same way for all rows in a dataframe. However, in some instances we want to assign different values to a new variable depending on a condition. For instance, we may want to create an indicator of obesity, which is defined as a body mass index of 30 kg/m^2 or more. Thus, a new variable obesity should take the value “no” for patients having bmi &lt; 30, or “yes” otherwise. This is called a conditional assignment, and can be done with function iflese(), which takes three arguments specified in this order: a condition that can be evaluated as either TRUE or FALSE, the value we want to assign when the condition is TRUE, and the value to be assigned when the condition is FALSE. This is done in the following script after computing bmi: d %&gt;% mutate(bmi = round(weight / (height/100)^2,1), obesity = ifelse(bmi &lt; 30, &quot;no&quot;, &quot;yes&quot;)) %&gt;% select(patient, bmi, obesity) # A tibble: 152 × 3 patient bmi obesity &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 1-001 29.4 no 2 1-002 27.8 no 3 1-003 30.3 yes 4 1-004 30.5 yes 5 1-005 30.4 yes 6 1-006 33.6 yes 7 1-007 28.4 no 8 1-008 24.3 no 9 1-009 23.6 no 10 1-010 30.5 yes # … with 142 more rows For more complex conditional assignments, several iflese()functions may be nested as in the following example: d %&gt;% mutate(bmi = round(weight / (height/100)^2,1), nutritional_status = ifelse(bmi &lt; 18.5, &quot;underweight&quot;, ifelse(bmi &lt; 25, &quot;normal weight&quot;, ifelse(bmi &lt;30, &quot;overweight&quot;, &quot;obesity&quot;)))) %&gt;% select(patient, bmi, nutritional_status) # A tibble: 152 × 3 patient bmi nutritional_status &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; 1 1-001 29.4 overweight 2 1-002 27.8 overweight 3 1-003 30.3 obesity 4 1-004 30.5 obesity 5 1-005 30.4 obesity 6 1-006 33.6 obesity 7 1-007 28.4 overweight 8 1-008 24.3 normal weight 9 1-009 23.6 normal weight 10 1-010 30.5 obesity # … with 142 more rows Nesting ifelse() functions is very flexible, and there is no limit to the number of nested levels, but it becomes difficult to follow if more than two or three nesting levels are necessary. If the condition depend on a single quantitative variable (as in this case, bmi) it is easier to use a different function allowing to define cutpoints, which is presented in the next section. 4.5.4 Categorization of quantitative variables A common type of derived variable is what results from the categorization of a numeric variable according to one or more cutpoints. For instance, suppose we want to create age groups by decades, i.e., group patients in bins defined by cutpoints 20, 30, 40, … and so on. This can be easily done using function cut(), that takes two arguments: the numeric variable we want to categorize, and the breaks or cutpoints we want to use, passed as a numeric vector such as c(20, 30, 40, ...). When the cutpoints are equidistant, it is practical to create this numeric vector with seq(), as done in the following script: d %&gt;% mutate(age = floor(as.numeric(rand_dt - birth_dt)/365.25), age_group = cut(age, breaks = seq(20, 70, 10))) %&gt;% select(patient, age, age_group) -&gt; foo foo # A tibble: 152 × 3 patient age age_group &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; 1 1-001 34 (30,40] 2 1-002 39 (30,40] 3 1-003 45 (40,50] 4 1-004 47 (40,50] 5 1-005 35 (30,40] 6 1-006 45 (40,50] 7 1-007 59 (50,60] 8 1-008 54 (50,60] 9 1-009 68 (60,70] 10 1-010 54 (50,60] # … with 142 more rows The result is a factor with the following levels: levels(foo$age_group) [1] &quot;(20,30]&quot; &quot;(30,40]&quot; &quot;(40,50]&quot; &quot;(50,60]&quot; &quot;(60,70]&quot; By default, intervals are defined from cutpoints as left-open and right-closed, using standard symbols ( and ] respectively. This means that the lower bound is not included in the interval, and the upper bound is included. For instance, a patient 40 years old is included in interval (30, 40] , and excluded from interval (40, 50]). Sometimes we may need left-closed and right-open intervals instead. For instance, the WHO nutritional status defines intervals in this way (note there is an error in the definition of the interval for Obesity class III, which is defined as Above 40; a patient with a BMI of exactly 40 does not fit in any of the classes! Therefore, the last class should be defined as 40 or more). We can produce this classification with cut(), using the argument right = FALSE, as done below. Note the use of count() to get the number of cases in each of the who_nsintervals. d %&gt;% mutate(bmi = round(weight / (height/100)^2,1), who_ns = cut(bmi, breaks = c(0, 18.5, 25, 30, 35, 40, Inf), right = FALSE)) %&gt;% count(who_ns) # A tibble: 6 × 2 who_ns n &lt;fct&gt; &lt;int&gt; 1 [18.5,25) 25 2 [25,30) 61 3 [30,35) 38 4 [35,40) 5 5 [40,Inf) 1 6 &lt;NA&gt; 22 We could also define custom labels for the resulting intervals as in the following: d %&gt;% mutate(bmi = round(weight / (height/100)^2,1), who_ns = cut(bmi, breaks = c(0, 18.5, 25, 30, 35, 40, Inf), labels = c(&quot;Underweight&quot;, &quot;Normal weight&quot;, &quot;Overweight&quot;, &quot;Obesity class I&quot;, &quot;Obesity class II&quot;, &quot;Obesity class III&quot;), right = FALSE)) %&gt;% count(who_ns) # A tibble: 6 × 2 who_ns n &lt;fct&gt; &lt;int&gt; 1 Normal weight 25 2 Overweight 61 3 Obesity class I 38 4 Obesity class II 5 5 Obesity class III 1 6 &lt;NA&gt; 22 4.5.5 Grouping factor levels Sometimes we want to re-classify observations by pooling some of the levels of a factor. For instance, suppose we want a simpler classification of the nutritional status with a single obesity class obtained by merging the three obesity classes I, II and III. This can be done in with function recode() from the dplyr package as shown below. Note that we only need to specify the levels to recode, plus .default = levels(who_ns) to keep all other levels unchanged. d %&gt;% mutate(bmi = round(weight / (height/100)^2,1), who_ns = cut(bmi, breaks = c(0, 18.5, 25, 30, 35, 40, Inf), labels = c(&quot;Underweight&quot;, &quot;Normal weight&quot;, &quot;Overweight&quot;, &quot;Obesity class I&quot;, &quot;Obesity class II&quot;, &quot;Obesity class III&quot;), right = FALSE), simpler_ns = recode(who_ns, &quot;Obesity class I&quot; = &quot;Obesity&quot;, &quot;Obesity class II&quot; = &quot;Obesity&quot;, &quot;Obesity class III&quot; = &quot;Obesity&quot;, .default = levels(who_ns))) %&gt;% count(simpler_ns) # A tibble: 4 × 2 simpler_ns n &lt;fct&gt; &lt;int&gt; 1 Normal weight 25 2 Overweight 61 3 Obesity 44 4 &lt;NA&gt; 22 4.5.6 Character strings We sometimes need to use strings stored in a character variable to derive a new variable. For instance, variable patient is a character vector containing a code for the study center (hospital), a hyphen, and a patient number within the center. Suppose we want to have a variable with the center code. This can be done with substr(). Similarly, we could extract the number of patient in each center. d %&gt;% mutate(site = substr(patient, 1, 1), site_patient = as.numeric(substr(patient, 3, 5))) %&gt;% select(patient, site, site_patient) # A tibble: 152 × 3 patient site site_patient &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 1-001 1 1 2 1-002 1 2 3 1-003 1 3 4 1-004 1 4 5 1-005 1 5 6 1-006 1 6 7 1-007 1 7 8 1-008 1 8 9 1-009 1 9 10 1-010 1 10 # … with 142 more rows Function substr() always returns a character vector, as is the case of site above. However, we can easily get a numeric vector by wrapping substr() within as.numeric(), as we did for site_patient. Another common need is exactly the opposite of what we did: to combine two variables to form a new one. As an example, we recompose the patient variable from the two pieces obtained above, using paste(): d %&gt;% mutate(site = substr(patient, 1, 1), site_patient = substr(patient, 3, 5), recompose_patient = paste(site, site_patient, sep = &quot;-&quot;)) %&gt;% select(patient, site, site_patient, recompose_patient) # A tibble: 152 × 4 patient site site_patient recompose_patient &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 1-001 1 001 1-001 2 1-002 1 002 1-002 3 1-003 1 003 1-003 4 1-004 1 004 1-004 5 1-005 1 005 1-005 6 1-006 1 006 1-006 7 1-007 1 007 1-007 8 1-008 1 008 1-008 9 1-009 1 009 1-009 10 1-010 1 010 1-010 # … with 142 more rows Working with strings is always difficult, and we often face problems we did not cover in the previous examples. However, you should be aware that there is much more power in R for working with strings, including detection and substitution of complex patterns, fuzzy string matching, and translations from, or to other languages. In the resources section we provide some links which are relevant for working with strings. 4.6 Selecting valid cases In virtually all real studies, some of the patients included in the study database are not valid for analysis. Common causes for this are inappropriate enrollment of patients that do not meet all predefined selection criteria, and lack of critical data. Then, we need to get rid of these patients, and keep only those who are valid. Validity criteria are always functions of the variables in our data, so that we should be able to write an expression to retain valid patients only. For instance suppose we want to declare invalid only those patients having a missing in hr. The result is a dataframe with 151 rows, after removing the only case with missing hr, as shown below: d %&gt;% filter(!is.na(hr)) %&gt;% nrow() [1] 151 Note the use of the not operator ! in front of is.na() in the filter() function. This operator reverses the meaning of what follows. Therefore, if is.na(hr) means hr is missing, !is.na(hr) means hr is NOT missing. Sometimes you will need to drop all cases having a missing somewhere, so as to keep only cases with complete data. This is easily achieved with function na.omit(). d %&gt;% na.omit() -&gt; complete nrow(complete) [1] 124 colSums(is.na(complete)) patient birth_dt sex rand_dt group weight height nyha 0 0 0 0 0 0 0 0 sbp dbp hr 0 0 0 In a more realistic case, you may need to investigate different aspects of the data, including compliance with all selection criteria (collected in several variables) and availability of important variables. This may take deriving a new variable that summarizes several validity criteria (such as valid: yes or no), and then use this variable for selection of valid patients. In the SARA study, only patients that did not comply with the study selection criteria were declared invalid and excluded form all analyses. These patients were: 1-013, 1-038, 1-054, 2-012, 5-002, and 6-021. In the following script we define a vector invalid, and then use the %in% operator to identify rows in d where patient is one of those in invalid: invalid &lt;- c(&quot;1-013&quot;, &quot;1-038&quot;, &quot;1-054&quot;, &quot;2-012&quot;, &quot;5-002&quot;, &quot;6-021&quot;) d %&gt;% filter(patient %in% invalid) # A tibble: 6 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;fct&gt; &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-013 1955-01-01 male 2010-01-22 ADT 100 176 II 143 100 2 1-038 1953-05-03 male 2011-03-14 CA 106 180 II 142 107 3 1-054 1943-05-16 female 2011-11-07 CA 67 162 I 130 84 4 2-012 1951-12-05 male 2010-06-25 CA 110 180 I 120 70 5 5-002 1946-03-12 male 2009-09-16 CA 85 179 I 133 87 6 6-021 1969-12-22 male 2011-01-31 ADT NA NA I 140 90 # … with 1 more variable: hr &lt;dbl&gt; To subset dretaining all the remaining patients, we just use the not operator in front of the same expression to get just the opposite result, i.e., patients not in the invalid vector. d %&gt;% filter(!(patient %in% invalid)) # A tibble: 146 × 11 patient birth_dt sex rand_dt group weight height nyha sbp dbp &lt;chr&gt; &lt;date&gt; &lt;fct&gt; &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1974-11-15 male 2009-05-11 CA 104 188 I 110 70 2 1-002 1970-02-27 male 2009-05-12 ADT 92 182 I NA NA 3 1-003 1964-02-21 female 2009-06-11 CA 95 177 I 125 70 4 1-004 1962-01-04 female 2009-07-20 CA 80 162 I 139 63 5 1-005 1974-06-02 male 2009-08-17 ADT 93 175 I 122 74 6 1-006 1964-06-22 male 2009-09-21 CA 115 185 I 120 80 7 1-007 1950-06-30 male 2009-10-01 CA 89 177 I 126 102 8 1-008 1955-03-29 male 2009-10-06 CA 77 178 I NA NA 9 1-009 1941-07-25 female 2009-11-10 ADT 62 162 I 140 85 10 1-010 1955-04-22 male 2009-11-17 ADT 86 168 I 122 83 # … with 136 more rows, and 1 more variable: hr &lt;dbl&gt; 4.7 Saving the R script Saving the R script that performs all the needed data preparation tasks is critical if we want this process to be reproducible. This is why we should always save the data preparation script, rather than its result, the tidy dataframe. There is no need to save the tidy data if we can reproduce it at no cost4, and as we will see, there is a very easy way to run the data preparation script once it has been saved to a file. The following script accumulates what we have done in previous sections, from the reading of raw data to the selection of valid cases: # reading raw data, cleaning and renaming vars d &lt;- read_excel(&quot;data/SARA_simplified.xlsx&quot;) %&gt;% clean_names() %&gt;% rename(patient = patient_no, birth_dt = birth_date_yyyymm_dd, rand_dt = date_of_randomization, group = random_allocation_of_treatment, weight = body_weight_at_baseline_kg, height = body_height_at_baseline_cm, nyha = nyha_classification_at_baseline, sbp = sbp_at_baseline_mm_hg, dbp = dbp_at_baseline_mm_hg, hr = heart_rate_at_baseline_bpm) %&gt;% # fixing problems in weight (commas instead of points!), and dates mutate(weight = as.numeric(sub(pattern = &quot;,&quot;, replacement = &quot;.&quot;, x = weight, fixed=TRUE)), birth_dt = as.Date(birth_dt), rand_dt = as.Date(rand_dt, &quot;%d/%m/%Y&quot;)) # data changes (after verification in hospital records) d$sex[d$patient == &quot;3-001&quot;] &lt;- 1 d$nyha[d$patient == &quot;1-005&quot;] &lt;- 1 d$nyha[d$patient == &quot;3-004&quot;] &lt;- 1 d$weight[d$patient == &quot;4-001&quot;] &lt;- 83 d$height[d$patient == &quot;4-001&quot;] &lt;- 167 d$hr[d$patient == &quot;6-030&quot;] &lt;- NA # invalid patients invalid &lt;- c(&quot;1-013&quot;, &quot;1-038&quot;, &quot;1-054&quot;, &quot;2-012&quot;, &quot;5-002&quot;, &quot;6-021&quot;) # derived vars sara &lt;- d %&gt;% # define factors mutate(sex = factor(sex, levels = 1:2, labels = c(&quot;male&quot;, &quot;female&quot;)), nyha = factor(nyha, levels = 1:3, labels = c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;)), group = factor(group, levels = c(&quot;Catheter ablation&quot;, &quot;Antiarrhythmic drug treatment&quot;), labels = c(&quot;CA&quot;, &quot;ADT&quot;))) %&gt;% # define new variables mutate(age = floor(as.numeric(rand_dt - birth_dt)/365.25), age_group = cut(age, breaks = seq(20, 70, 10)), bmi = round(weight / (height/100)^2,1), obesity = factor(ifelse(bmi &lt; 30, &quot;no&quot;, &quot;yes&quot;)), who_ns = cut(bmi, breaks = c(0, 18.5, 25, 30, 35, 40, Inf), right = FALSE), simpler_ns = recode(who_ns, &quot;Obesity class I&quot; = &quot;Obesity&quot;, &quot;Obesity class II&quot; = &quot;Obesity&quot;, &quot;Obesity class III&quot; = &quot;Obesity&quot;, .default = levels(who_ns)), site = substr(patient, 1, 1)) %&gt;% filter(!(patient %in% invalid)) %&gt;% # sort by patient arrange(patient) %&gt;% # define order of variables in dataframe select(patient, site, birth_dt:group, age, age_group, height, weight, bmi, simpler_ns, everything(), -who_ns) rm(invalid, d) After filtering valid cases, we used arrange() to ensure that rows will be sorted by patient, and select() to sort the variables as desired. Finally, we removed intermediate objects we no longer need with rm(). In the select() statement, note some useful possibilities: colons to indicate groups of adjacent variables (as in birth_dt:group). everything() to indicate all the remaining, non-mentioned variables. negative sign preceding a variable to drop it (-who_ns). We now print the first rows of sara to verify the result: sara # A tibble: 146 × 17 patient site birth_dt sex rand_dt group age age_group height weight &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;fct&gt; &lt;date&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1-001 1 1974-11-15 male 2009-05-11 CA 34 (30,40] 188 104 2 1-002 1 1970-02-27 male 2009-05-12 ADT 39 (30,40] 182 92 3 1-003 1 1964-02-21 fema… 2009-06-11 CA 45 (40,50] 177 95 4 1-004 1 1962-01-04 fema… 2009-07-20 CA 47 (40,50] 162 80 5 1-005 1 1974-06-02 male 2009-08-17 ADT 35 (30,40] 175 93 6 1-006 1 1964-06-22 male 2009-09-21 CA 45 (40,50] 185 115 7 1-007 1 1950-06-30 male 2009-10-01 CA 59 (50,60] 177 89 8 1-008 1 1955-03-29 male 2009-10-06 CA 54 (50,60] 178 77 9 1-009 1 1941-07-25 fema… 2009-11-10 ADT 68 (60,70] 162 62 10 1-010 1 1955-04-22 male 2009-11-17 ADT 54 (50,60] 168 86 # … with 136 more rows, and 7 more variables: bmi &lt;dbl&gt;, simpler_ns &lt;fct&gt;, # nyha &lt;fct&gt;, sbp &lt;dbl&gt;, dbp &lt;dbl&gt;, hr &lt;dbl&gt;, obesity &lt;fct&gt; names(sara) # to see variable order [1] &quot;patient&quot; &quot;site&quot; &quot;birth_dt&quot; &quot;sex&quot; &quot;rand_dt&quot; [6] &quot;group&quot; &quot;age&quot; &quot;age_group&quot; &quot;height&quot; &quot;weight&quot; [11] &quot;bmi&quot; &quot;simpler_ns&quot; &quot;nyha&quot; &quot;sbp&quot; &quot;dbp&quot; [16] &quot;hr&quot; &quot;obesity&quot; The R script above should be saved to file, with an appropriate name such as “data_preparation.R”, in the same folder where the raw_data is located (e.g., the study folder). Once this is done, you can start a fresh new R session and run this script using function source() with the complete file name as argument (don’t forget the quotes and the .R file extension!). As long as your working directory is the study folder, this will run the script, and the sara dataframe will appear in your workspace (i.e., Environment pane): source(&quot;data_preparation.R&quot;) You are now ready for statistical analysis! Resources The forecats package provides useful functions to work with factors (and there is a Factors with forcats Cheat Sheet. The lubridate package provides useful functions to work with dates (and there is a Dates and Times Cheat Sheet. The stringr package provides useful functions to work with strings (and there is a Work with Strings Cheat Sheet. For exact matching of strings, see the help of the grep() function of base R. If you need fuzzy matching (approximate matching) of strings, see the help of the agrep() function of base for starters; if you want more, see packages fuzzywuzzyR; if you want to get mad, see package stringdist. The googleLanguageR package uses Google Cloud Translation API for language detection and translation of strings to a different language (e.g., Spanish to English). It comes at a price, though quite affordable if you don’t exceed a billion of characters per month (and free for the first 500000 characters). Exercises The following script generates a dataframe with a hospitalcode, and a within-hospital patient number. set.seed(1); d &lt;- data.frame(hospital = c(rep(1:5, each=20)), patient = rep(1:20, 5) - rpois(n = 100, 0.05), sex = sample(c(&quot;male&quot;, &quot;female&quot;), replace = TRUE, size = 100), age = floor(rnorm(100, mean=45, sd=15))) head(d) hospital patient sex age 1 1 1 female 35 2 1 2 female 45 3 1 3 female 31 4 1 4 male 47 5 1 5 male 35 6 1 6 male 71 Create a unique case identifier by combining hospital and patient into a single variable case_id. Is case_id really unique? If it’s not, investigate what is/are repeated case_id value(s), and what are their positions (rows) in the dataframe Fix the problem by appending “a” or “b” to the case_id, so that it is unique. Amend the following data errors: The true age of the 16 year old patient is 26. Patient 1 in hospital 1 is not a female, but a male. The top age for this study was 75 years, so that any patient older than 75 is invalid. Eliminate these patients from the tidy dataframe. How many patients are left? Read this data of an observational study on pre-hypertension (previous stage to arterial hypertension) conducted in relatives of patients with arterial hypertension (the units of quantitative variables are whole years for age, cm for height and abdominal circumference, kg for weight, and mmHg for SBP and DBP). Ensure that all variable have appropriate names in snake_case, and that the case identifier is unique. Investigate the number of missings in this dataset. What are the variables containing missings? How many missings are there in each variable? Look at the minimum and maximum values of numeric variables. Are there gross errors, like impossible or very suspicious values? Define factors for all categorical variables (see the coding here). Compute the following derived variables: age_group: defined as working age (15-64 years) or elderly (65 years or older). bmi: the body mass index (BMI) (kg/^2), rounded to 1 decimal. nutritional status: defined as underweight (BMI &lt; 18.5), normal weight (18.5–24.9), overweight (25.0–29.9), or obesity (30 or above). Keep only the patients having complete data (no missings). Reorder variables so that derived variables come immediately after those they depend on. Ensure rows are ordered by subject number. Save your R script to a file with the name “pre_hta_data_preparation.R”, start a fresh R session, and verify your working directory is the folder where you saved the file (check this by running getwd()). Without opening the script in the RStudio editor, run it with source(\"pre_hta_data_preparation.R\"). Answer these questions: How many patients are left? Are there any missings? What is the mean of bmi? How many patients are there in each nutritional status category? Overriding the dataframe you start with (d in this case) is not a good idea unless you have tested the code and are pretty sure it works well. For testing, use a different name, so that you do not loose d if something goes wrong.↩︎ In studies with lots of data and/or very complex data preparation, the R script may be very long and take too much time to be executed. In these cases, it is reasonable to save not only the data preparation script, but also the resulting tidy dataframe.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
