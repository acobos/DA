[["index.html", "Data Analysis for Clinical Researchers Preface", " Data Analysis for Clinical Researchers Albert Cobos Preface This is an introductory book on data analysis for clinical researchers. Data analysis methods are presented through real data examples relevant to clinical research. We focus on concepts, interpretation, and statistical thinking, avoiding or minimizing the mathematical basis of statistical methods, in line with the Guidelines for Assessment and Instruction in Statistics Education (GAISE), and with modern data science. Data analysis requires the use of some software to read and analyze data, and to produce some outputs. There are lots of software tools one may use for this purpose, such as SAS, SPSS, Stata, and many other. This book is based on the R language (R, for short), a programming language for statistical computing and graphics. These are the main reasons to choose R: It is a free and open-source software under the GNU General Public License. May be used with the three major platforms: Windows, Linux and Mac. Has very good graphic capabilities. Is well documented, including an easily accessible help system. It is extensible, and has a growing and very active user community. "],["structure-of-this-book.html", "Structure of this book", " Structure of this book In chapter 1 we present the tools use throughout the book: R and RStudio. Chapter 2 is an introduction to data structures frequently used in R to store data. This is a wearisome subject, but it is important to become familiar with R. The remaining chapters follow the chronological order of tasks to be carried out in any real case of data analysis: acquire the data (chapter 3), prepare the data for analysis (chapter 4), explore the data (chapter 5), conduct inferential analyses (chapters 6-9), and report the results (chapter 10). In this book you will find R tutorials in gray areas containig R code, just like this one: # This will print the date of your system in the console Sys.Date() By hovering the cursor over the top-right corner of gray area, you will be able to copy the whole of its contents, and paste it in the RStudio editor. It is extremely important that you run the R code shown in tutorials (in the first tutorial we provide detailed instructions on how to do this). R programming is a skill, and you won’t develop skills by just reading how to do something. Rather, you need to get your hands dirty by doing. In this case, this means to write R code or, at least copying it and running it to see what happens. "],["introduction-to-r-and-rstudio.html", "1 Introduction to R and RStudio 1.1 Installing R and RStudio 1.2 First R session 1.3 R objects 1.4 R functions 1.5 Installing R packages 1.6 Loading packages Resources Exercises", " 1 Introduction to R and RStudio In this chapter you are going to be introduced to R and RStudio. R is a programming language particularly suited for data analysis and data visualization (via graphics), and its free. Rstudio is an integrated development environment (IDE) that greatly facilitates to work with R, and there is also a free desktop version. 1.1 Installing R and RStudio First of all, you need to have R ad RStudio installed in you computer. I you don’t have them, you should proceed as follows: Install the last version of R from the CRAN website; see how in this video. Install the free Desktop version of RStudio from here. Now you have both R and RStudio and, for starters, I recommend you to look at the short video Take a tour of RStudio’s IDE, here. As you have seen in the video, the RStudio screen is divided in different areas or panes, some of which have several tabs. This is a very short description of the main purpose of some of these panes and tabs: The top-left pane is and editor where you can write R code. It is likely that you won’t see this pane when you launch RStudio for the first time after installation. The bottom-left pane is the R Console, and here is where text results will be printed. You can also write R code in the console, after the prompt symbol (&gt;), and submit it by pressing Enter. The top-right pane has several tabs: The Environment tab shows the R objects created in an R session, and its empty if you have not created any. Example of objects are a collection of data, a graphic, or the results obtained by a statistical analysis procedure, to name a few. The History tab shows a log of all the commands you have submitted in a session. The Tutorial tab contains interactive tutorials. The bottom-right pane has several tabs: The Files tab shows the contents of the folder R is pointing to, and is similar to the file explorer in Windows. The Plots tab is where graphics are displayed. The Packages tab is to see and manage R packages. In a fresh installation of R, you will see many packages, but many more can be easily installed from this tab. The Help tab is where you can look for information of specific R commands or functions, and contains several resources to learn R and RStudio, R manuals, and more. The Viewer tab is used to show results that are formatted in specific ways, such as html. This is a lot of information, and is presented just for reference. But don’t worry, you will get familiar with all these as you use RStudio. 1.2 First R session It’s time to open RStudio and have your first R session, proceeding as follows: Open RStudio Open a new scripting tab using the menu option File &gt; New file &gt; R script: a new tab will appear in the top-left pane, with name Untitled1. Copy the R script in the gray area below and paste it in this new tab (you can easily copy the script using the Copy to clipboard icon that will appear on hovering the cursor over the top-right corner of the gray area). Place the cursor in the very first line you pasted, and press Ctrl+Enter (or click the Run icon in the top-right corner of the Untitled1 tab). The code will be submitted to the console and the result will be printed below. In addition, the cursor will move to the next line, so that you can directly press Ctrl+Enter again to run the line. Note that texts preceded by a hash (#) are a comments, and are ignored by the R interpreter. In this first tutorial we show how to use R as a calculator, and we introduce some common mathematical functions, such as sqrt(), exp(), log(), and round(). # Arithmetic operators 10 + 2 # addition 10 - 2 # subtraction 10 * 2 # multiplication 10 / 2 # division 10 ^ 2 # power # Combine them (10 * 2 + 5) / 5^2 # Mathematical functions 2 * 10 -1 # usual precedence rules 2 * (10 -1) # use brackets for precedence sqrt(25) # square root exp(1) # exponential log10(100) # decimal log log(10) # natural log # Combine functions with arithmetic operators or with other functions sqrt(25) * log10(100) / 10^2 # Nested functions: use functions within functions sqrt(exp(2)) # square root of the exponential of 2 exp(sqrt(2)) # exponential of the square root of 2 # Round to the desired number of decimals round(3.141593, 2) round(3.141593, 0) round(3.141593) Once you have finished the tutorial, you can save the script in the Untitled1 pane to a file, using the save button, or the File &gt; Save menu option. This will open a dialog from which you can navigate to a desired folder, provide a file name (e.g. my_first_R_session) and click the Save button. A new file will appear in the folder you chose, named my_first_R_session.R. The .R extension means that this is an R script file. If you save an R script to file, you will be able to reopen it in RStudio using the menu option File &gt; Open file.... We recommend you save the scripts of all the tutorials in this book, so that by the end of it you will have a nice collection of examples to refer to in the future. 1.3 R objects In the previous tutorial we produced some results that were printed in the console, but we did not save any. In this tutorial you will learn how to store your results in objects. In particular, you will learn: how to create an object by assigning some result to an object name with the assignment operator &lt;- (a handy way to compose this operator in RStudio is by pressing Alt+-). that R is case-sensitive: lowercase and uppercase letters are not the same (\\(A \\ne a\\)). how to remove objects from the workspace (Environment tab), with function rm(). how to save the objects in the workspace to a file, with function save.image(). how to know what is the current working directory in an R session (the folder of your computer R is pointing to), with function getwd(). how to load these file at a later time, with function load(). Before you start, ensure that the workspace (Environment tab) is empty. If it’s not, you can delete all objects listed by using the brush icon in the Environment tab of the top-right pane of RStudio. # Create object by assigning a name to a value or expression, # using the assignment operator: &lt;- weight &lt;- 90 height &lt;- 1.80 BMI &lt;- weight / height^2 # These objects now appear in the Environment tab # When you create an object, its contents is NOT printed in the console # to print (the contents of) an existing object, just run its name weight BMI # Object names cannot include blank spaces body weight &lt;- 90 # this is wrong (and gives an error) body_weight &lt;- 90 # this is ok # The assignment operator is an arrow composed with a left angle bracket (&lt;) and # a hyphen or dash (-), WITHOUT any space between them weight &lt; - 50 # this is wrong... but does not give error: why? # Case sensitivity bmi # gets an error: there is no object with this name BMI # ok Round(BMI, 1) # gets an error: there is no function with this name round(BMI, 1) # ok # Care when using both upper and lowercase names a &lt;- 1 A &lt;- 2 A == a # is A equal to a ? a A # Remove objects with function rm() rm(body_weight, a, A) # Now the environment has only three objects: BMI, height and weight # Save your workspace (i.e., all objects in there) to a file save.image(&quot;my_objects.RData&quot;) # A file of name &quot;my_objects.RData&quot; was saved to your working directory # The working directory is the folder R is pointing to. # But what is this folder? getwd() # Now, close RStudio and reopen it for a fresh new session, or # simulate a new session by just removing all objects in the workspace. # This will load the file you saved load(&quot;my_objects.RData&quot;) # Now you should see the objects you the objects back in the Environment tab Note that, with RStudio, you can change the working directory using the menu option Session &gt; Set working directory. 1.4 R functions An R function is what we use to make something happen. Functions perform a specialized task and provide a result. In previous sections we used some functions, like log(), round(), and Sys.Date(), but there are many other built-in functions in R. In the following tutorial we discuss some general ideas about R functions, how to use them and how to get help on them. To use a function we write its name followed by brackets. Often (but not always), we write some things within the brackets which are the function arguments. A function may take one or more arguments, or no arguments at all. When a function takes more than one argument, we separate them with commas. # a function with no arguments Sys.Date() # a function call with one argument round(10/3) # a function call with two arguments (comma separated) round(10/3, 2) # a function call with three arguments (comma separated) hist(rnorm(100), main = &quot;Histogram (n = 100)&quot;, xlab = &quot;Z score&quot;) The arguments a function can take do have names. When calling the function, arguments are identified by name (if explicit), or by position (otherwise). For instance, the round function can take two arguments: x: the number we want to round digits: the number of decimals # arguments identified by name: order is irrelevant round(digits = 2, x = 10/3) # arguments identified by position: order is relevant! round(10/3, 2) # a mixture of both; order is relevant for arguments not explicitly named! round(10/3, digits = 2) # how to know the arguments a function can take, and their names? # looking at the function help with ?function_name, e.g.: ?round The help of a function is always structured in several sections, like Description, Usage, Arguments, Details, and Examples. In the Arguments section you can see what are the argument names, an explanation of what they are, and their order. You can access the help of a function by running its name (without the brackets!) after a question mark (e.g., ?round), or writing the function name in the search box of the RStudio Help tab. 1.5 Installing R packages R is a software structured in packages. A package is a bunch of functions packed together. When you install R, a collection of packages is downloaded to your computer. If you look at the Packages tab of RStudio you will see the packages already installed. For instance, you will see packages base and stats, which are downloaded in the basic installation of R. However, there are many other packages available in the CRAN repository, and you need to know how to install them. For instance, there is a package called mosaic you will probably not find among your installed packages. Since we will use this package in future chapters, it’s a good idea to install it. To install this (or any other) package, click the Install button in the Packages tab of RStudio and you will be presented the dialog shown in figure 1.1. Figure 1.1: Dialog to install a package You only need to write the name mosaic in the Packages box, or pick it from the list that will appear as you start writing, and click on the Install button. Be sure the Install dependencies box is checked (dependencies are other packages needed by the one you are installing). You will notice that, when you click the Install button, the following is written in the R console: install.packages(&quot;mosaic&quot;) This means that the install.packages() function is what is actually used to install packages, and the Install button in RStudio only sends this to the console. After running this function, you will see a confirmation message in the console (package ‘mosaic’ successfully unpacked and MD5 sums checked). Installing a package means downloading it to your computer, and therefore is a one time operation: you need to do it just once per R installation. 1.6 Loading packages In previous sections we have used functions from packages in the base R installation such as round(), log() and others. These functions are readily available in any R session, but this is not the case of functions contained in packages you install. For instance, the following script calls favstats(), a function from the mocaisc package, but when we run it we get an error message stating that function favstats() was not found: favstats(age ~ sex , data = HELPrct) Error in favstats(age ~ sex, data = HELPrct): could not find function &quot;favstats&quot; Thus, to use a function from packages you have installed, you need to do something special, and there are two options: prefix the function with the package name plus ::, (e.g., mosaic::favstats()), or load the package first using function library(). # Option 1 mosaic::favstats(age ~ sex , data = HELPrct) sex min Q1 median Q3 max mean sd n missing 1 female 21 31 35 40.5 58 36.25234 7.584858 107 0 2 male 19 30 35 40.0 60 35.46821 7.750110 346 0 # Option 2 library(mosaic) favstats(age ~ sex , data = HELPrct) sex min Q1 median Q3 max mean sd n missing 1 female 21 31 35 40.5 58 36.25234 7.584858 107 0 2 male 19 30 35 40.0 60 35.46821 7.750110 346 0 As you see in the previous scripts, both options work, but while library(mosaic) in option 2 loads the entire package into memory, prefixing the function with the package name (option 1) does not. Another important difference is that prefixing the function with the package name makes explicit the function you are using, and this is important because some packages have functions sharing their name with some base R functions. For instance: The base package has a function mean() (see ?base::mean). The mosaic package has a function mean() (see ?mosaic::mean). Thus, which one is going to be used when we call mean()? Well, if you load the mosaic package with library(mosaic), the following warning is printed in the console: The following objects are masked from ‘package:base’: max, mean, min, prod, range, sample, sum) This means that, from now on in your session, every time you call one of the functions mentioned in the above message (e.g., mean()), the one from mosaic will be used. However, when you look at a script and see a call to mean(), it is hard to know if this refers to mean() from the base package, or to mean() from the mosaic package. Prefixing a function with the package name (e.g., mosaic::mean()) removes any possible ambiguity, and for this reason, is considered a good programming practice. Last, in case you prefer to avoid prefixing functions with the package name, remember to load the package first with library() and to do it in every new R session. While installing a package is a one time operation, loading an installed package is an operation you need to do in every R session (every time you open RStudio). Resources CRAN is the official website of R. Here you can not only download R, but also find useful information, such as the CRAN task views providing guidance on which packages are relevant for tasks related to a certain topic. The RStudio website has a Resources section where you can find webinars and videos, cheatsheets and books, among other things. A two-pages RStudio IDE Cheat Sheet. R-bloggers is a blog on R publishing lots of articles on the use of R, including tutorials for learning R. A post is R-bloggers on how to use the help page for a function in R Another post is R-bloggers with a complete guide to installing R packages form CRAN and other R package repositories. Quick-R is an extremely well organized website on R, particularly useful for beginners. There are sections on data management, statistics, graphics and more. Exercises Look at the help of round() and read sections Description and Usage. What do you get when using floor(10/3) and ceiling(10/3)? In the Usage section you will see round(x, digits = 0). What do you think digits = 0 means? (hint: read the explanation of round in the Description section). Start at fresh RStudio session (or empty the workspace) and write a script in a new editor tab (File &gt; New File &gt; R script) to: Create an object with name my_weight taking the value of your body weight, in kilograms. Create an object with name my_height taking the value of your body height, in meters (remember to use the dot as decimal separator, e.g. 1.78) Compute the body mass index (by dividing the weight over the square of the height) and assign it to an object with name BMI. Round the value of BMI to the first decimal. Look for a package called dplyr in the Packages tab of RStudio. If you are working with a new installation of R, you will not find it. Then, install this package using the Install button in this tab. When the installation finishes, verify that this package now appears in the Packages tab. Open RStudio and investigate what is your working directory with function getwd(). Then change it to another folder of your preference with the menu option Session &gt; Set working directory &gt; Choose Directory.... When done, use again getwd() to see what is now the working directory. "],["r-data-structures.html", "2 R data structures 2.1 Vectors 2.2 Lists 2.3 Dataframes 2.4 Factors 2.5 Dates 2.6 Other data structures Resources Exercises", " 2 R data structures The term data structures refers to objects devoted to store data. There are many different data structure in R. In this chapter we introduce the most basic, and commonly used, data structures. 2.1 Vectors Vectors are the simplest possible (or atomic) objects in R, and they are ordered collections of elements. There are six types of vectors in R, but here we will be concerned with the three types listed in table 2.1. Table 2.1: Vector types Type Elements are: Example numeric (real) numbers 1, 0, 3.14, 1984 character quoted character strings “Yes”, “No”, “Maybe” logical unquoted logical values TRUE, TRUE, FALSE, TRUE A vector can contain any number of elements, but all of them have to be of the same type: we cannot mix different data types in a single vector (e.g., character and numeric elements). In the following tutorial you will learn how to create vectors with function c(), verify what is the type of a vector with function class(), and what is the number of its elements with function length(). A vector can have missing elements, and these are represented with the symbol NA. Last, you will see how to get particular elements in a vector with the subsetting operator [], and how to set them using the assignment operator &lt;-. # Creating vectors with function c() ages &lt;- c(51, 65, 90, 93, 72) # a numeric vector ages antec &lt;- c(&quot;stroke&quot;,&quot;AMI&quot;,&quot;Breast ca.&quot;) # a character vector antec current_smoker &lt;- c(FALSE, FALSE, TRUE) # a logical vector current_smoker mixed &lt;- c(67, &quot;stroke&quot;, FALSE) # try to mix types: no error issued ? mixed # but coerced to character (note the quotes) # Getting the type of a vector class(ages) class(antec) class(current_smoker) # Getting the number of elements in a vector length(ages) length(antec) length(current_smoker) # Use the symbol NA for missing elements more_ages &lt;- c(69, NA, 37) more_ages all_ages &lt;- c(ages, more_ages) # can concatenate vectors with c() all_ages # Getting/setting vector elements # Refer to an element by position using square brackets: all_ages all_ages[7] # gets the 7th element all_ages[7] &lt;- 65 # sets the 7th element to 65 all_ages # verify all_ages[3:6] # gets elements from positions 2 to 4 Very often we need of perform arithmetic operations with numeric vectors. For instance, we may want to compute the body mass index (BMI) from a vector body weights and a vector of body heights. Then, we may want to compute summary statistics of the BMI values, like the mean and standard deviation. weight &lt;- c(51, 65, 90, 93, 85) # weights of five patients height &lt;- c(1.65, NA, 1.85, 1.80, 1.60) # heights of the same five patients # Arithmetic operations bmi &lt;- round(weight / height^2, 1) # compute BMI bmi # result is NA if height or weight is NA # Statistical functions mean(weight) # the mean of weights median(weight) # the median sd(weight) # the standard deviation summary(weight) # some of the previous at once # Care with missings! # If missing data (NA), you need to set argument na.rm = TRUE # in most statistical functions: mean(bmi) # since some values are NA, result is NA mean(bmi, na.rm=TRUE) # removes NA for calculation sd(bmi) # same for sd() sd(bmi, na.rm=TRUE) summary(bmi) # but not needed for summary() Also, a very common task is to compare the elements of a numeric vector to some threshold value using relational operators such as ==, !=, &gt;, or &gt;=. We can also compare two vectors x and y element-wise, provided they have the same length (e.g., x == y). In any case, the result of a comparison is always a logical vector. Note that the equality operator is not a single (=) but a double equal sign (==): try to remember this, it’s very common mistake! Another very common mistake is to compare something to NA using the equality operator (==): this does not work, and function is.na() should be used for this purpose. Comparisons ar illustrated in the following tutorial, which is a continuation of the previous one (do not empty the workspace!). # Relational operators for comparisons bmi == 18.7 # is bmi equal to 18.7? note the DOUBLE equal sign! bmi != 18.7 # is x different from 18.7? bmi &lt; 25 # is bmi less than 25? bmi &lt;= 25 # is bmi less than, or equal to 25? bmi &gt; 30 # is bmi greater than 30? bmi &gt;= 30 # is v greater than, or equal to 30? # Can also compare two vectors having the same number of elements x &lt;- c(1, 0, 0, 0, 1, 0, 0, 0, 1) y &lt;- c(0, 0, 1, 1, 1, 1, 1, 0, 0) x == y x == y x &gt; y x &lt;= y # Very important! bmi == NA # this does not work with NA is.na(bmi) # use this instead Character vectors are useful to store textual information like diseases, symptoms or drugs. However, working with character vectors is often a challenge for several reasons. First, a word may be written in lowercase, uppercase, or a mixture of both. Because R is case sensitive, “stroke” is not the same as “STROKE”. Second, white spaces are also characters (though they do not catch the eye!) and therefore “stroke” and “stroke” are also different. For these reasons, it is sometimes useful to convert character vectors to uppercase (or lowercase), and to know how to remove leading or trailing blanks. Here is a demo: # Working with character vectors antec &lt;- c(&quot;stroke&quot;, &quot; stroke &quot;, &quot;Breast cancer&quot;, &quot;STROKE&quot;, &quot; Stroke &quot;) # Remember case sensitivity: # &quot;stroke&quot;, &quot; stroke &quot;, &quot;STROKE&quot;, and &quot; Stroke &quot; are different things! antec == &quot;stroke&quot; toupper(antec) # convert to uppercase tolower(antec) # convert to lowercase trimws(antec) # remove leading and trailing blanks tolower(antec) == &quot;stroke&quot; # useful for comparisons trimws(tolower(antec)) == &quot;stroke&quot; # better A very useful function to combine strings is the paste() function. In fact, you can combine not only strings, but also numeric values (that will be coerced to character). Sometimes we need to know what is the number of characters of the elements of a character vector, and this can be done with function nchar(). patient_no &lt;- 1:5 age &lt;- c(62, 88, 35, 75, 81) sex &lt;- c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;) paste(patient_no, sex) # paste corresponding elements paste(patient_no, sex, sep = &quot;: &quot;) # can define a separator (default: blank space) # Can paste more than two vectors, and mix with constants strings (&quot;Patient&quot;, &quot;is a&quot;) # note that constants are recycled (i.e., reused for all elements) narrative &lt;- paste(&quot;Patient&quot;, patient_no, &quot;is a&quot;, age, &quot;years old&quot;, sex, &quot;with antecedent of&quot;, trimws(tolower(antec))) narrative # Number of elements and number of characters length(narrative) # the number of elements in vector nchar(narrative) # the number of characters of each element Other common tasks with the strings of character vectors are to extract just a part of them, or to substitute a part of them. These can be done with functions substr() (for substring) and sub() (for substitute), respectively. In both functions we indicate the character vector from which to extract or substitute a part in argument x. In substr() we need to specify the part we want to extract from x by indicating the first and last positions in arguments start and stop. In sub() we need to specify the pattern to be replaced, the replacement string, and the addition argument fixed = YES to avoid alternative interpretations of the pattern argument 1. # Extract a part of the string substr(narrative, start = 16, stop = 23) # characters 16 to 23 substr(narrative, 16, 17) # characters 16 to 17 substr(narrative, 16, nchar(narrative)) # characters 16 to last # Replace a part of the string sub(pattern = &quot;is&quot;, replacement = &quot;was&quot;, x =narrative, fixed = TRUE) Whatever the type of a vector, its elements can be named. We can provide names for the elements of a vector when creating it with function c(), or later with names() &lt;- . x &lt;- c(Peter = 31, Paul = 28, Mary = 25) x names(x) # gives the names as a character vector names(x)[3] # therefore, you can refer to any element names(x)[3] &lt;- &quot;Adeline&quot; # or set any element x y &lt;- 1:3 # a numeric vector names(y) # whose elements have no names names(y) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # but we can set them later y Last, it is possible to make type conversions. For instance, you may need to convert a numeric vector containing zeros and ones to a logical vector, or viceversa. Sometimes, you want to extract part of a string containing digits with substr(). However, because a part of a string is by definition a string as well (even if it contains only digits!), we need to convert these to numeric. Other conversions are less common but possible, using a family of functions (the as. family). In some instances, type conversions are done automatically. For example if we try to sum the elements of a logical vector. Because addition is an operation defined for numbers, logical values will be coerced to numeric behind the scene, as shown at the end of the following tutorial on type conversions. number_of_seizures &lt;- 0:4 number_of_seizures # numeric to logical (rule: 0 -&gt; FALSE, anything else -&gt; TRUE) seizures &lt;- as.logical(number_of_seizures) seizures # character to numeric x &lt;- substr(narrative, 16, 17) # extracts the age x class(x) # but the result is a character vector age &lt;- as.numeric(x) # now it&#39;s a numeric vector age # logical to numeric (rule: FALSE -&gt; 0, TRUE -&gt; 1) diabetes &lt;- c(TRUE, TRUE, FALSE, FALSE) as.numeric(diabetes) # character to numeric or logical (less common) z &lt;- c(&quot;0&quot;, &quot;One&quot;,&quot;2&quot;,&quot;120&quot;, &quot;TRUE&quot;, &quot;FALSE&quot;, &quot;Are you tired?&quot;) z as.numeric(z) # only digits converted to numbers as.logical(z) # only words &quot;TRUE&quot; and &quot;FALSE&quot; converted to logical # Automatic conversion from logical to numeric (rule: FALSE -&gt; 0, TRUE -&gt; 1) sum(diabetes) Ops! just one more thing. In R, scalars (single numbers) are considered vectors of length one. Same for a single character string, or a single logical value. So, nothing exists in R simpler than a vector! x &lt;- 3.14 class(x) is.vector(x) length(x) x &lt;- &quot;A&quot; class(x) is.vector(x) length(x) x &lt;- FALSE class(x) is.vector(x) length(x) 2.2 Lists In the previous section we have seen that vectors cannot mix data types, but lists can. In fact, lists can mix not only data types, but object types. Lists are arbitrary collections of objects (including other lists!), and therefore provide a highly flexible structure to store data of any kind. Lists can be created with function list(), by enumerating its elements separated by commas. The length of a list is the number of elements it contains, and can be obtained with length(). # Creating a list x &lt;- list(&quot;male&quot;, # 1st element 79, # 2nd element c(&quot;arterial hypertension&quot;, &quot;diabetes&quot;, &quot;stroke&quot;), # 3rd element matrix(c(260,110, 190, 100, 185, 100, 160, 95), nrow=2, # 4th element dimnames = list(BP = c(&quot;SBP&quot;, &quot;DBP&quot;), day = 1:4))) x class(x) # object type? length(x) # number of elements it contains When working with lists, to common operations are subsetting and extraction: Subsetting a list means taking a part or subset of the list elements, and the result is always a list (even when we subset just one of its elements!); this is done with the subsetting operator: []. Extracting from a list, means getting an element of the list, and the result will not be a list, but an object of the class this element belongs to; this is done with the extraction operator: [[]]. When applied to vectors, these two operators produce the same result (x[3] == x[[3]]), but this is not the case with lists. For instance, in the example above, we created a list with data of a patient, the second of which is the age, a numeric vector of length one. Suppose we want to get this value and plug it in some mathematical formula to make a prediction. In this case we need to extract these element (x[[2]]), the result being a numeric vector we can use in arithmetic expressions. However, if we subset the second element of the list (x[2]), the result will be a list of length one (but still a list!), and we cannot plug a list in a mathematical formula. The following tutorial demonstrates these important difference. # Subset a list with the SUBSETTING operator: [] x[1:2] class(x[1:2]) # the result will be ALWAYS another list x[2] # even when subsetting just one element! class(x[2]) # see? # Extract an element from a list with the EXTRACTION operator: [[]] x[[2]] class(x[[2]]) # the result is the element class (numeric vector in this case) # We can use numeric vectors in mathematical expressions, but NOT lists! x[[2]] + 10 # is OK x[2] + 10 # is WRONG People is often confused about the difference between x [2] and x[[2]]. If this is your case, think of a list a set of numbered boxes each one containing something, and suppose that box number 2 contains a sandwich. Subsetting the list means taking some of the boxes, maybe just one, maybe just box number 2, but you still have a box in your hands and you can`t eat a box! If you want to eat your sandwich, you open the box to extract your sandwich, and then you eat it. If you are hungry, you better understand the difference between subsetting a list and extracting from a list. Just like vectors, lists can be named, and the names of elements can be provided when creating the list or later with names(). In the previous tutorial we saw how to extract a single element from a list indicating its position with the extraction operator [[]]. When a list has names, we can extract elements by position, but also by name, using either the extraction operator or the construct listname$elementname. The last is very practical, and is shown below: # Provide names when creating the list x &lt;- list(sex = &quot;male&quot;, age = 79, antecedents = c(&quot;arterial hypertension&quot;, &quot;diabetes&quot;, &quot;stroke&quot;), matrix(c(260,110, 190, 100, 185, 100, 160, 95), nrow=2, dimnames = list(BP = c(&quot;SBP&quot;, &quot;DBP&quot;), day = 1:4))) x names(x) # get the names names(x)[4] # 4th element has no name names(x)[4] &lt;- &quot;BP&quot; # let`s set it names(x) # all named now # Extract an element x[[1]] # by position x[[&quot;course&quot;]] # by name x$age # by name, using $ x$sex x$antecedents x$BP Lists are very important data structures for several reasons, but one of them is because the results of many functions in R, including functions for statistical analysis, are lists. For instance, in the following tutorial we use a binomial test2 to evaluate if the probability of boy and girl is the same from a series of 100 deliveries. Then, we inspect the result to realize it is a list, we investigate the name of its elements, and we extract some of them. # A binomial test for the probability of boy being 0.5 # suppose we observe n = 100 births, among which x = 45 are boys res &lt;- binom.test(x = 45, n = 100) res class(res) # class &quot;htest&quot; is a specialized type of list, but still a list is.list(res) # see? names(res) # get the names of its elements res$p.value # get the p.value res$estimate # get the proportion of boys res$conf.int # get the confidence interval for this proportion 2.3 Dataframes Dataframes are named lists of vectors having the same length. Because they are lists, they can mix vectors of different types, which makes them ideal to store tabular data (arranged in rows and columns). Dataframe vectors are the columns of a data frame, and are usually called variables. Dataframes can be created with data.frame(), by enumerating its vectors separated by commas. These can be already existing vectors, or vectors we create on the fly. The length()of a dataframe is the number of variables it contains. Because dataframes are named lists of vectors, we can refer to these dataframe variables using the construct dataframename$variablename. This can be used in conjunction with the assignment operator ro add a new variable to a dataframe, or to remove an existing variable from a dataframe (by passing it NULL), as shown in this tutorial. sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) w &lt;- c(60, 69.5, 83.9, 76.3, 77.3, 88.8) # Creating a dataframe form vectors of the same length) d &lt;- data.frame(case = 1:6, # vector created on the fly age = c(25, 32, 19, 41, NA, 56), # same sex, # already existing vector weight = w) # same, but give it name d class(d) length(d) # number of variables (columns) ncol(d) # same nrow(d) # the number of rows names(d) # get variable names as a character vector # Get dataframe variables d[[2]] # by position d$age # by name class(d$age) # class of this object? class(d$sex) # Note that sex and d$sex are two different objects sex == d$sex # equal by now sex[3] &lt;- NA # change sex sex # verify change d$sex # d$sex remains unaltered # Add variable to a dataframe d$height &lt;- c(165, 175, 158, 180, 175, 160) length(d) d # Remove variable from a dataframe d$case &lt;- NULL length(d) d The dataframe() function is not the only way to create a dataframe. In the next chapter you will learn how to read data stored in an external file (e.g., an Excel file), resulting in a dataframe. This is in fact the most common way to create dataframes. 2.4 Factors A factor is the data structure used in R to represent categorical variables. Categorical variables are classifications having a number of classes, categories or levels. Examples of categorical variables are sex (male or female), smoker (never smoked, ex-smoker or current smoker) or previous surgery (yes or no). Data on categorical variables are usually stored as either a character vector of level descriptors (e.g., “male”, “male”, “female”, …), or as a numeric vector using numeric codes (e.g., 1 for males, 2 for females). Factors are created with function factor(). The first argument to this function is the (numeric or character) vector containing the data. If numeric, we need to clarify the meaning of numeric codes, with two additional arguments: levels: to specify the numeric codes (as a numeric vector) labels: to specify the corresponding texts (as a character vector) The following script shows how to create a factor from a numeric vector of codes, or from a character vector. We first create a numeric vector x using the rep() function (to repeat values 1 and 2, five times), and then define a factor from it. x &lt;- rep(1:2, 5) # numeric vector using rep() x # Creating a factor from a numeric vector sex &lt;- factor(x, levels = c(1,2), labels = c(&quot;male&quot;, &quot;female&quot;)) sex class(sex) A couple of things are worth noting in the previous example. First, both levels and labels have to be passed as vectors. Second, it is the order of levels and labels what establishes their correspondence: first level with first label, and so on. Last, when a factor (like sex) is printed to the console, its values are not surrounded by quotes (as is the case with character vectors), and the levels of the factor are stated after printing the values. Let’s now see how to define a factor from a character vector. In this case, if the strings of this vector are self-explanatory (e.g., “male”, o “female”), we can avoid further specifications. However, the levels will be defined in alphabetical order, and this is not always what we want. If we want a specific ordering of levels, we can just define them in the levels argument. Last, if the strings are not self-explanatory, or we want to change them, we can also use the labels argument. The following script illustrated these three options. x &lt;- rep(c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;), 2) x # option 1: levels and labels not explicitly defined hb &lt;- factor(x) hb class(hb) levels(hb) # option 2: define levels to force desired ordering hb &lt;- factor(x, levels = c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;)) hb class(hb) levels(hb) # option 3: define levels and labels x &lt;- rep (c(&quot;l&quot;, &quot;n&quot;, &quot;h&quot;), 2) hb &lt;- factor(x, levels = c(&quot;l&quot;, &quot;n&quot;, &quot;h&quot;), labels = c(&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;)) hb class(hb) levels(hb) You may be wondering why we should care about the order in which the levels of a factor are defined. The point is that it has implications for graphics, tables and statistical analyses. For instance, when we tabulate results for a factor, its levels appear in the order they are defined. Also, the first level of a factor, which is sometimes called the reference level, is the one other levels are compared to in ANOVA or regression models. For this reasons, it is convenient to ensure the order of levels is a reasonable one. 2.5 Dates Date is the class of objects used to represent dates in R. There are two related object classes that are used to represent date-time values (values that combine date and time, such as “21/03/2020 07:45:28”): POSIXct, and POSIXlt. When we have just date values (e.g., “21/03/2020), the appropriate class to use is Date. Dates can be created from a character vector with as.Date(). The format argument is used to specify the formatting of the character strings. If these are formatted as yyyy-mm-dd, we don’t need to specify the format value, but otherwise we need to specify it. Dates can be created from POSIXct and POSIXlt objects as well. # From a character vector of yyyy-mm-dd values x &lt;- c(&quot;1958-03-05&quot;, &quot;1991-10-28&quot;) x class(x) dob &lt;- as.Date(x) dob class(dob) # From a character vector of dd/mm/yyyy values x &lt;- c(&quot;05/03/1958&quot;, &quot;28/10/1991&quot;) x class(x) dob &lt;- as.Date(x, format = &quot;%d/%m/%Y&quot;) dob class(dob) # see help on format symbols (Details section) ?strptime # From POSIXct or POSIXt values x &lt;- as.POSIXct(c(&quot;1958-03-05 07:30:04&quot;, &quot;1991-10-28 10:05:39&quot;)) x class(x) dob &lt;- as.Date(x) dob class(dob) The reason why we should dates stores in a Date object is to allow computations. For instance, we can compute the current age from birth dates. Or, we can determine the date in ninety days from today. When we operate on dates, the result is not a standard numeric value, but a difftime object. However, we can convert to numeric with as.numeric(). This is recommended before further operations with time intervals. dob &lt;- as.Date(c(&quot;1958-03-05&quot;, &quot;1991-10-28&quot;)) # birth dates dob class(dob) today &lt;- Sys.Date() # current date today class(today) today + 90 # 90 days from today # Current age age &lt;- today - dob1 # difference as number of days age class(age) # a difftime object # Use as.numeric to get standard numeric vector age &lt;- as.numeric(today - dob1) age class(age) # To compute age in years we divide the NUMERIC version by 365.25 age_in_years &lt;- as.numeric(today - dob1) / 365.25 age_in_years # Use floor() to get whole years age_in_years &lt;- floor(as.numeric(today - dob1) / 365.25) age_in_years 2.6 Other data structures The data structures covered in previous sections are those you will be using again and again, so it’s really important you get familiar with them. There are many other data structures in R, but by now you don’t need to know them. However, let’s just introduce two addition data structures, because you may find them when looking at the help of some functions. These are matrices and arrays. A matrix is just a vector with a dim attribute defining the dimensions of the matrix, that is, the number of rows and number of columns. A matrix can be created with function matrix(), or by defining the dim attribute of a vector with dim(). Like vectors, matrices cannot mix data types (e.g., character and numeric). x &lt;- 1:10 # a vector x class(x) # Create a matrix of 2 rows and 5 cols m &lt;- matrix(x, nrow = 2) m dim(m) class(m) dim(x) # vectors do not have a dim attribute dim(x) &lt;- c(2, 5) # but we can define it x # and now its a matrix class(x) dim(x) Matrices are a special case of a more general data structure called array. In fact, a matrix is an array with two dimensions (rows and columns) but, in general, arrays are multidimensional data structures. Arrays are created with function array(), or by defining the dim attribute of a vector. x &lt;- 1:30 # Creating an three-dimensional array a &lt;- array(x, dim = c(3, 5, 2)) a class(a) dim(a) dim(x) # vectors do not have a dim attribute dim(x) &lt;- c(3, 5, 2) # but we can define it x # and now its an array class(x) dim(x) For more information on matrices and arrays see this section of the first edition of the book Advanced R by Hadley Wickham. Resources A very useful base R cheat sheet: a pdf with only two pages! Objects types and some useful R functions for beginners is a post in R-bloggers where you can find many of the concepts we covered in this chapter, and more. Fore a more thorough discussion of what we covered in this chapter, look at Data structures in the first edition of the book Advanced r by Hadley Wickham. Exercises Before undertaking each exercise, ensure your workspace is clean (i.e., there are no objects in the Environment pane). Create a vectors of body weights in kilograms (w) and a vector of body heights in centimeters (h), with the following values: w: 47.3, 87.0, 80.9, 85.1, 95.4, 90.0, 70.3, 46.9, 86.7, 72.2, 74.0 h: 160, 165, 180, 170, 190, 180, 172, 156, 170, NA, 169 Then compute the body mass index (kg/m^2), store it as bmi, and write appropriate expressions to: Verify that bmi is a numeric vector. Get the number individuals with low weight (BMI below 18.5). Get the number individuals with (BMI of 25 or more). Get the number individuals with obesity (BMI of 30 or more). Is there anyone having a BMI of 25? Is there anyone having a BMI of 30? Get the number of missings in bmi. Get the mean and standard deviation of bmi values. Hint: remember that the result of a comparison is a logical vector, and that the sum of a logical vector is the number of TRUEs it contains. LETTERS and lettersare built-in vectors containing all the letters in the alphabet (print them in the console to see them). Using this vectors and the paste() function, get the following character vectors: One whose first element is “A is in position 1 of the alphabet” (and similar statements for the remaining letters). Hint: use 1:length(LETTERS). One whose first element is “A is an LETTER, and a is a letter” (and similar statements for the remaining letters). One with the first five LETTERS only. The letter in position 20. Last, try this: x &lt;- c(5, 14, 4); LETTERS[x]. Can you devise a way to get the same result with just one expression rather than two? The following are five CIP codes, whose structure is as follows: the first four characters are initials of surname and first name, the first digit is a code for sex (0 for male, 1 for female), followed by birth date in format yyddmm, and three trailing zeros: YAGU0741511000, DEFO0702702000, GITI1642102000, AOPU1620401000, BABE0740206000 Define a vector cip containing these CIP codes. Then, from this vector: Get a vector with the years of birth in format yyyy (4-digits years). Using only the year of birth (ignore month and day of birth), get an estimate of their ages by 2050. Get a vector with first element “YAGU was born in 1974” (and analogous for the remaining persons). See the help of the rep() function by running ?rep, and look at the first two examples. Use this function to create three vectors containing the following elements: 0, 1, 0, 1, 0, 1 0, 0, 0, 1, 1, 1 “male”, “female”, “male”, “female”, “male”, “female” See the help of the seq() function by running ?seq, and look at the examples. Use this function to create vectors containing: All multiples of five up to 100. All odd numbers between zero and ten. The following four probabilities: 0.2, 0.4, 0.6, 0.8. Run the following code to conduct a t-test on the lwb data in package COUNT: library(COUNT) data(lbw) res &lt;- t.test(bwt ~ smoke, data = lbw) res What is the class of object res? Is it a list? What are the names of the elements in res? Get the p-value of the test, with 3 decimals. Get the means of bwt for smokers and non-smokers, rounded to one decimal. Get their difference with function diff(), and round to one decimal. Get the confidence interval for this difference, rounded to one decimals. In one step, crate a dataframe with these data: first_name age sex Peter 33 male Paul 29 male Mary 25 female Then extend this dataframe with the following additional variables: case_id containing numbers 1 to 3. age_in_10y reflecting the age the each patient will have in 10 years from now. older_than_30 as TRUE or FALSE. is_male as TRUE of FALSE. Remove variable male from the dataframe What is now the length of the dataframe? and what is the number of rows? Using the rep() function, create numeric vector x with the sequence 1,2,3 repeated 3 times (so 9 values), an then define a factor from x with labels “good”, “neutral” and “bad”. Create a character vector x with two repetitions of the vector c(“never-smoker”, “ex-smoker”, “current-smoker”), and then define a factor from x. Is the ordering of levels good enough? Redefine the factor with a better ordering. Create two Date objects: one with today’s date, and the other with your date of birth. Then, use these objects to: Compute your age in days Compute your age in (whole) years Print your date of birth, including the weekday Print a calendar of ten weekly celebrations, starting today. When fixed = FALSE (the default value), this is interpreted as a regular expression; regular expressions are a powerful way to manipulate strings, but are out of the scope of this book.↩︎ This and other statistical tests will be introduced in future chapters. Our purpose here is to show how the results of statistical tests are organized, not their meaning.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
